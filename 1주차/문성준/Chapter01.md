# ch01 객체, 설계

---

# 결론 : 이론보다 실무가 먼저

처음부터 결론을 말해서 당황스러울 수도 있을 것이다.
하지만 내가 말하고자 하는 것은 코드를 먼저 타이핑해보고 이론을 공부하는 것이 좋다는 것이다.
또한 프로그래밍은 이론이 정립되기 전에 항상 실무에서 데이터가 쌓여야지 이론으로 채택되어지는 것이다.

---

### 이 책의 목적

훌륭한 OOP을 설계하고 유지보수하는 데 필요한 원칙과 기법을 설명하기 위해 쓰여진 책

---

## 예시) 티켓 판매 app

인스턴스를 생성하는 시점에 제약을 강제할 수 있도록 생성자를 추가

객체 지향 프로그래밍에서 객체의 생성에 있어 초기 상태를 안전하게 관리하는 방법에 관한 것이다. 
생성자를 사용하면 객체가 생성될 때 필수적인 값이나 설정을 강제할 수 있게된다.
즉, 객체의 인스턴스를 만들 때 필요한 조건이나 규칙을 생성자를 통해 명시함으로써, 객체가 올바른 상태로 생성되도록 보장하는 방법을 말하고자 한다. 이를 통해 객체의 무결성을 유지하고, 잘못된 상태의 객체가 생성되는 것을 방지할 수 있게된다.

---

### 나만의 코드로 알아보자.

예를 들어, 은행 계좌 객체를 생성할 때 계좌 소유자의 이름과 초기 잔액이 필수적이라고 가정.
이러한 필수 정보 없이는 계좌 객체가 의미가 없거나 잘못된 상태로 존재할 수 있다,
생성자를 통해 이러한 필수 정보를 강제하면, 객체가 올바른 상태로 초기화되어 생성되도록 할 수 있게 된다.

```java
public class BankAccount {
    private String owner;
    private double balance;

    public BankAccount(String owner, double balance) {
        if (owner == null || owner.isEmpty()) {
            throw new IllegalArgumentException("Owner cannot be null or empty");
        }
        if (balance < 0) {
            throw new IllegalArgumentException("Balance cannot be negative");
        }

        this.owner = owner;
        this.balance = balance;
    }
}
```

이런 식으로 구성할 수 있게 된다는 말이다.
이 예에서 생성자는 계좌 소유자의 이름과 초기 잔액이 제공되어야 하며, 이 두 조건이 충족되지 않으면 객체가 생성되지 않도록 함. 이렇게 하면 객체의 일관성과 무결성을 유지할 수 있게 되는 것이다.
즉, 객체지향적으로 설계 되었다고 봐도 무방하다.

책에서는 나의 예시와는 다르게 매표소, 티켓판매자, 청중가 이렇게 크게 3개의 객체로 나누고 행위에 대해서 나눴다.

---

# 소프트웨어 모듈의 3가지 목적

1. 실행 중에 제대로 동작
2. 변경을 위해 존재
3. 코드를 읽는 사람과 의사소통하는 것

책에서 나오는 초반부의 코드는 변경 용이성과 읽는 사람과의 의사소통이라는 목적을 만족시키지 못한다.
WHY? → 관람객과 판매원이 소극장의 통제를 받는 수동적인 존재이기 떄문이다.
”이게 왜 문제라는 거야?” 라고 생각할 수도 있다.
(책을 읽었다는 가정하에 몇몇 스토리 생략)하지만, 조금만 생각을해보면 가방을 마음대로 열어 본다는 데 있다.
소극장이 나의 허락도 없이 매표소에 보관중인 티켓과 현금에도 마음대로 접근할 수 있기 때문이다.

현실의 CGV를 생각 해보자. 

과연 매표소 알바생이 우리의 가방 또는 지갑을 마음대로 꺼내서 결제하는게 말이 되는 것인가?
절대 아니다. 이는 우리가 생각한대로 로직이 구현되어 있지 않음을 나타낸다.

또한 각 모델이 결합도가 높기 떄문에 모든 사실을 동시에 기억해서 사용 해야한다.
→ 만약, 사전에 인지해야 하는 것이 많을 때, 이 코드를 본다면 과연 기억할 수 있을까?
→ 절대 불가능하다.
하지만, 가장 심각한 문제는 모델의 행위를 변경할 경우 연관되어 있는 모든 것을 바꿔야 한다는 것이다.

### 변경에 취약한 코드

만약, 결합도(의존성)가 높다면 지나치게 세부적인 사실에 의존해서 동작한다.
즉, 객체 사이의 의존성과 관련된 문제라는 것이다.

***목표 : app의 기능을 구현하는 데 필요한 최소한의 의존성만 유지하고 불필요한 의존성을 제거하는 것이다.***

객체 사이의 의존성이 과한 경우엔 “결합도가 높다”고 말한다.

따라서 설계의 목표는 객체 사이의 결합도를 낮춰 변경이 용이한 설계를 만드는 것

### 설계 개선

매표소에서 지갑에 직접 접근하는 것은 자신의 일을 스스로 처리해야 한다는 우리의 직관을 벗어난다.

해결) 너무 세세한 부분까지 알지 못하도록 정보를 차단하면 된다.

즉, 자율적인 존재로 만들자는 것이다. (극장은 극장 안에 인원 수만 채우면 다른 사항은 고려x)

### 자율성을 높이자

```java
// 1
public class Theater{
	private TicketSeller ticketSeller; // 이런 식으로 Theater 내부에 숨기고
	
	public Theater(TicketSeller ticketSeller){
		this.ticketSeller = ticketSeller; // 이렇게 세팅해줌
	}

	// 구현체
	...
}
// 2
public class TicketSeller{
	private TicketOffice ticketOffice; // 이런 식으로 Theater 내부에 숨기고
	
	public TicketSeller(TicketOffice ticketSeller){
		this.ticketSeller = ticketSeller; // 이렇게 세팅해줌
	}

	// 구현체
	public void enter(Audience audience){
		ticketSeller.sellTo(audience)
	}
}
```

접근 가능한 public 메서드가 더 이상 존재하지 않기 때문에 외부에서는 직접 접근할 수 없다.
이처럼 개념적이나 물리적으로 객체 내부의 세부적인 사항을 감추는 것을 캡슐화.

캡슐화의 목적은 변경하기 쉬운 객체를 만드는 것 → 의존성 및 결합도를 낮추고, 자율성을 높인 코드

이렇게 함으로써 극장은 단지 티켓판매자가 sellTo 메시지를 이해하고 응답할 수 있다는 사실만 알고 있을 뿐이다.

---

<aside>
📌 **설계원칙**
객체를 인터페이스와 구현으로 나누고, 인터페이스만을 공개하는 것은 객체 사이의 결합도를 낮추고 변경하기 쉬운 코드를 작성하기 위해 따라야 하는 가장 기본적인 설계원칙이다

</aside>

이렇게 캡슐화를 개선한 후에 크게 달라진 점은 내부 구현을 외부에 노출하지 않고 자신의 문제를 스스로 책임지고 해결한다는 것이다. 다시말해 ‘자율적인 존재가 된 것’을 의미한다.

밀접하게 연관된 작업만을 수행하고 연관성이 없는 작업은 다른 객체에게 위임하는 객체를 응집도가 높다고 말한다. 즉, 자율적인 객체를 만들면 결합도를 낮출 수 있을뿐더러 응집도를 높일 수 있게 되는 것이다.

---

변경하기 쉬운 설계는 한 번에 하나의 클래스만 변경할 수 있는 설계다.

---

<자주 쓰는 용어 정리> 

- 알아두시면 좋습니다

**OOP** : 데이터와 프로세스가 동일한 모듈 내부에 위치하도록 프로그래밍하는 방식.

**트레이드오프** : Give and Take → 상충관계**,** 다른 측면에서 이득을 얻으면서 집합 또는 디자인의 품질, 양, 속성을 없애거나 잃어버리는 일이 수반되는 상황적 결정. 즉, 하나를 얻으면 다른 하나를 잃을 수 있는 관계

---

절차적/객체 지향적의 차이는 책임의 이동이라고 생각한다.
→ 객체지향적 설계 및 구현을 통해 스스로 책임을 지게 만들기 떄문이다.

→ 또한, 절차적은 클래스 단위로 먼저 생각하고 구현하지만 객체지향적 설계는 객체의 행위에 대해서 먼저 생각을 하고 설계 및 구현을 하게 된다.

---

다시 강조하면,
설계를 어렵게 만드는 것은 **의존성.**
해결 방법은 불필요한 의존성을 제거함으로써 객체 사이의 **결합도**를 낮추는 것이다.

***즉, 최소한의 의존성만 남기는 것이 훌륭한 객체지향 설계다.
또한, 모든 객체들이 자율적으로 행동하는 설계를 말한다.***

이해하기 쉽고 변경하기 쉬운 코드를 작성하고 싶다면 차라리 한 편의 애니메이션을 만든다고 생각하는 것이 좋다.
또한, 변경을 수용할 수 있는 설계가 중요한 이유는 client 요구사항이 항상 변경되기 때문이다.

단순히 데이터와 프로세스를 객체라는 덩어리 안으로 밀어 넣었다고 해서 변경하기 쉬운 설계를 얻을 수 있는 것은 아니라는 점을 유의하자.

---

<aside>
📌 설계란,
트레이드오프의 산물이기 때문에 좋은 설계를 하기란 쉽지않다. 아니, 오히려 어렵다고 할 수 있다.
그래서 더욱 재밌는 것 같다. 설계를 하면 할수록 연관관계에 대해 어떻게 설정할 지 고민하는 과정 속에서 내가 발전할 것이니까.

</aside>

---

### 의인화

또한, 능동적이고 자율적인 존재로 소프트웨어 객체를 설계하는 원칙을 의인화라고 한다.
