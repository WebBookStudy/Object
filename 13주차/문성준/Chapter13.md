# ch13 서브클래싱과 서브타이핑

---

---

서브타입을 목적으로 상속을 사용할 때 고려해야 하는 규칙과 원칙

## 서론

상속이 두 가지 용도로 사용된다느 사실을 이해하는 것이 가장 중요하다.

### 상속의 용도

1. **타입 계층 구현**
타입 계층 안에서 부모 클래스는 일반적인 개념을 구현하고 자식 클래스는 특수한 개념을 구현한다.
타입 계층의 관점에서 부모 클래스는 자식 클래스의 일반화이고 자식 클래슨느 부모의 특수화다.
2. **코드 재사용**
상속을 사용하면 점진적으로 애플리케이션의 기능을 확장할 수 있다.
재사용을 위해 상속을 사용할 경우 강하게 결합되기 때문에 변경하기 어려운 코드를 얻으므로 지양해야한다.

따라서, **상속을 사용하는 목적은 무조건 “타입 계층 구현”하는 것이어야만 한다.**

→ 다형적으로 동작하는 객체들의 관계에 기반해 확장 가능하고 유연한 설계를 얻을 수 있게 된다.

### **일반화**

일반화는 보다 범용적이고 광범위한 개념을 나타냅니다. 상속 관계에서 부모 클래스는 보다 일반적인 개념을 나타내며, 자식 클래스들의 공통적인 속성과 행동을 정의합니다. 일반화를 통해, 다양한 하위 타입들이 공유할 수 있는 기본적인 구조와 행동을 추출하여 공통의 부모 클래스에 정의할 수 있습니다. 이는 코드 재사용을 촉진하고, 유지 관리를 용이하게 합니다.

예를 들어, "동물" 클래스는 모든 동물이 공통으로 가지고 있는 속성과 행동을 정의할 수 있는 일반적인 개념입니다. 이 클래스에는 "먹다", "자다"와 같은 메서드가 포함될 수 있습니다.

### **특수화**

특수화는 일반화의 반대 개념으로, 보다 구체적이고 특정한 개념을 나타냅니다. 상속 관계에서 자식 클래스는 부모 클래스보다 더 특정한 속성이나 행동을 추가하여 구체화합니다. 자식 클래스는 부모 클래스의 속성과 행동을 상속받으며, 그 위에 추가적인 특성이나 메서드를 정의하여 특정한 개념을 구현합니다.

"동물" 클래스를 상속받는 "고양이" 클래스는 "동물"의 특수한 형태로, "동물" 클래스에 정의된 일반적인 행동을 상속받으면서 "야옹하다"라는 고양이만의 특별한 행동을 추가로 정의할 수 있습니다.

### **상속을 통한 일반화와 특수화의 예**

```java
class Animal {
    void eat() {
        System.out.println("This animal eats food.");
    }

    void sleep() {
        System.out.println("This animal sleeps.");
    }
}

class Cat extends Animal {
    void meow() {
        System.out.println("The cat meows.");
    }
}

class Dog extends Animal {
    void bark() {
        System.out.println("The dog barks.");
    }
}

```

이 예에서 **`Animal`** 클래스는 먹고 자는 일반적인 행동을 정의하며, **`Cat`**과 **`Dog`** 클래스는 **`Animal`**의 특수한 형태로, 각각의 고유한 행동(야옹하기, 짖기)을 추가하여 구체화합니다.

일반화와 특수화는 객체 지향 설계에서 중요한 개념이며, 상속을 통해 타입 계층을 구성하고 코드의 재사용성을 높이는 데 기여합니다. 하지만, 상속이 강한 결합을 만들어 변경과 확장을 어렵게 만들 수 있으므로, 상속을 사용할 때는 신중하게 고려해야 합니다.

상태와 행동을 캡슐화한 객체를 조합해서 프로그램을 구성하는 방식을 가리킨다.

상속과 다형성을 지원한다는 점에서 객체 기반 프로그래밍과 차별화된다.

클래스가 존재하지 않는 프로토타입 기반 언어를 사용.

---

# 타입

## 개념 관점의 타입

우리가 인지하는 세상의 사물의 종류를 의미한다.

우리가 인식하는 객체들에 적용하는 개념이나 아이디어를 가리켜 타입이라고 부릅니다.
타입은 사물을 분류하기 위한 틀로 사용됩니다.
어떤 대상이 타입이 분류될 때 그 대상을 타입의 인스턴스라고 부릅니다. = 객체

## 프로그래밍 언어 관점의 타입

프로그래밍 언어에서 타입은 두 가지 목적을 위해 사용됩니다. 
(데이터를 사용하는 애플리케이션에 의해 결정된다)

1. 타입에 수행될 수 있는 유효한 오퍼레이션의 집합을 정의한다
2. 타입에 수행되는 오퍼레이션에 대해 미리 약속된 문맥을 제공한다

## 객체지향 패러다임 관점의 타입

1. 개념 관점에서 타입이란 공통의 특징을 공유하는 대상들의 분류다.
2. 프로그래밍 언어 관점에서 타입이란 동일한 오퍼레이션을 적용할 수 있는 인스턴스들의 집합이다.

객체의 타입이란 객체가 수신할 수 있는 메시지의 종류를 정의하느 ㄴ것이다.

퍼블릭 인터페이스는 객체가 수신할 수 있는 메시지의 집합이다.

> 객체의 퍼블릭 인터페이스가 객체의 타입을 결정한다.
따라서 동일한 퍼블릭 인터페이스를 제공하는 객체들은 동일한 타입으로 분류된다.
> 

객체에게 중요한 것은 속성이 아니라 행동이라는 사실이다.

<aside>
📌 객체를 바라볼 때는 항상 객체가 외부에 제공하는 행동에 초점을 맞춰야 한다.
객체의 타입을 결정하는 것은 내부의 속성이 아니라 객체가 외부에 제공하는 행동이라는 사실이다.

</aside>

---

# 타입 계층

내연관점에서 일반화란 어떤 타입의 정의를 좀 더 보편적이고 추상적으로 만드는 과정을 의미한다.
반대로 특수화란 어떤 타입의 정의를 좀 더 구체적이고 문맥 종속적으로 만드는 과정을 의미한다.

집합을 의미하는 외연의 관점에서 일반적인 타입의 인스턴스 집합은 특수한 타입의 인스턴스 집합을 포함하는 슈퍼셋이다.

- 일반화 : 다른 타입을 완전히 포함하거나 내포하는 타입을 식별하는 행위 또는 그 행위의 결과를 가리킨다.
- 특수화 : 다른 타입 안에 전체적으로 포함되거나 완전히 내포되는 타입을 식별하는 행위 또는 그 행위의 결과를 가리킨다.

슈퍼타입

- 집합이 다른 집합의 모든 멤버를 포함한다
- 타입 정의가 다른 타입보다 좀 더 일반적이다

서브타입

- 집합에 포함되는 인스턴스들이 더 큰 집합에 포함된다
- 타입 정의가 다른 타입보다 좀 더 구체적이다

## 객체지향 프로그래밍과 타입 계층

객체의 타입을 결정하는 것은 퍼블릭 인터페이스다.

슈퍼타입 : 서브타입이 정의한 퍼블릭 인터페이스를 일반화시켜 상대적으로 범용적이고 넓은 의미로 정의한 것

서브타입 : 슈퍼타입이 정의한 퍼블릭 인터페이스를 특수화시켜 상대적으로 구체적이고 좁은 의미로 정의한 것

일반적인 타입과 구체적인 타입 간의 관계를 형성하는 기준이 ‘퍼블릭 인터페이스’라는 사실만은 꼭 알고 있자.

다시 한번 강조한다.

서브타입의 인스턴스는 슈퍼타입의 인스턴스로 간주될 수 있다.
→ 상속과 다형성의 고나계를 이해하기 위한 출발점이다.

---

# 서브클래싱과 서브타이핑

상속을 이용해 타입 계층을 구현한다는 것은 부모 클래스가 슈퍼타입의 역할을, 자식 클래스가 서브 타입의 역할을 수행하도록 클래스 사이의 관계를 정의한다는 것을 의미한다.

타입 계층을 구현할 때 지켜야 하는 제약사항을 클래스와 상속의 관점에서 살펴보자.

## 언제 상속을 사용해야 하는가 ?

상속의 올바른 용도는 타입 계층을 구현하는 것이다.

다음과 같은 2가지 질문을 해보고 두 질문에 모두 “예”인 경우만 상속을 사용하자.

1. 상속 관계가 is-a 관계를 모델링 하는가 ?
2. 클라이언트 입장에서 부모 클래스의 타입으로 자식 클래스를 사용해도 무방한가 ?

### is-a관계

자식은 부모다. “타입 S는 타입 T다(S is-a T)”

먼저 익숙한 두 가지 사실에서 이야기를 시작하자.

- 펭귄은 새다.
- 새는 날 수 있다.

is-a 관계가 배신한 것을 알 수 있다.

코드로 구현해봐도, “펭귄은 새고, 따라서 날 수 있따”라고 주장한다.
기대되는 행동에 따라 타입 계층을 구성해야 한다는 사실을 너무나도 잘 보여준 예시이다.
따라서 타입 계층의 의미는 행동이라는 문맥에 따라 달라질 수 있따.

단지 울음 소리를 낼 수 있단느 행동만 기대한다면 새와 펭귄을 타입 계층으로 묶어도 무방하다.
따라서 슈퍼타입과 서브타입 관계에서는 **is-a 보다 행동 호환성이 더 중요**하다.

어떤 방식으로 사용되고 협력하는지 살펴본 후에 상속의 적용 여부를 결정해도 늦지 않다.

## 행동 호환성

출발점은 타입이 행동과 관련이 있다는 사실에 주목하자.
행동에 연관성이 없다면 is-a 관계를 사용하지 않아야 한다.

결론은 두 타입 사이에 행동이 호호나될 경우에만 타입 계층으로 묶어야 한다는 것이다.
행동의 호환 여부를 판단하는 기준은 **클라이언트의 관점**이라는 것이다.

→ 클라이언트 입장에서 몯느 새가 날 수 있다고 가정하기 떄문이다.
중요한 것은 클라이언트의 기대다.

자식 클래스의 경우 컴파일러는 업캐스팅을 허용한다.

“펭귄이 새다”라는 말에 현혹당한 채 상속 계층을 유지할 수 이쓴ㄴ 해결 방법을 찾으려 할 것이다.
상속 관계를 유지하면서 문제를 해결하기 위해 시도해 볼 수 있는 세 가지 방법이 있다.

(447page)

1. 메서드를 오버라이딩해서 내부 구현을 비워두는 것이다.
2. 메서드를 오버라이딩한 후 예외를 던지게 하는 것이다.
3. 메서드를 수정해서 인자로 전달된 타입이 아닐 경우에만 메시지를 전송하도록 하는 것이다.

또 다른 인스턴스가 상속 계층에 추가된다면 어떻게 할 것인가 ? new 연산자와 마찬가지로 구체적인 클래스에 대한 결합도를 높인다 (코드를 추가해야하기 떄문) → 개방 -폐쇄 원칙을 위반한다.

---

## 클라이언트의 기대에 따라 계층 분리하기

클라이언트의 기대에 맞게 상속 계층을 분리하는 것뿐이다.

날 수 있는 새와 날 수 없는 새를 명확하게 구분할 수 있게 상속 계층을 분리하면 서로 다른 요구사항을 가진 클라이언트를 만족시킬 수 있을 것이다.

잘못된 객체와 협력해서 기대했던 행동이 수행되지 않거나 예외가 던져지는 일은 일어나지 않을 것이다.
이를 해결하는 방법은 클**라이언트에 따라 인터페이스를 분리 하는 것**이다.

***더 좋은 방법은 합성을 사용하는 것이다.***

### ISP 인터페이스 분리원칙

인터페이스 분리 원칙(ISP)은 "클라이언트는 자신이 사용하지 않는 메서드에 의존하면 안 된다"는 객체 지향 설계 원칙 중 하나입니다. 이 원칙은 소프트웨어 개발자들이 "지나치게 방대한 인터페이스"를 피하고, 대신 작고 구체적인 목적에 맞춰진 인터페이스를 만들어야 한다고 조언합니다. ISP는 SOLID 원칙 중 하나로, 좋은 소프트웨어 아키텍처를 구성하는 데 중요한 역할을 합니다.

### **ISP의 핵심 아이디어**

- **클라이언트 특화 인터페이스:** 각 클라이언트는 필요로 하는 메서드만을 포함하는 인터페이스에 의존해야 합니다. 이는 클라이언트가 사용하지 않는 메서드에 의존성을 갖게 되는 것을 방지합니다.
- **인터페이스 분할:** 크고 일반적인 목적의 인터페이스는 더 작고 구체적인 인터페이스들로 분할되어야 합니다. 이는 클라이언트가 필요로 하는 기능만을 제공함으로써, 시스템의 유연성과 유지보수성을 향상시킵니다.

### **ISP의 장점**

1. **유지보수성 향상:** 클라이언트가 실제로 사용하는 기능만을 포함하는 인터페이스를 제공함으로써, 코드의 변경이 다른 부분에 미치는 영향을 최소화합니다.
2. **재사용성 증가:** 작고 명확한 목적을 가진 인터페이스는 다른 맥락에서 재사용하기 더 용이합니다.
3. **결합도 감소:** 클라이언트가 자신이 필요로 하는 메서드만을 알고 있어야 하므로, 시스템 내의 결합도가 감소합니다.

다음은 ISP 원칙을 적용하지 않은 경우와 적용한 경우의 간단한 예시입니다.

### ISP 미적용 예시

```java
interface Worker {
    void work();
    void eat();
}

class HumanWorker implements Worker {
    public void work() {
        // 작업하는 코드
    }

    public void eat() {
        // 식사하는 코드
    }
}

class RobotWorker implements Worker {
    public void work() {
        // 작업하는 코드
    }

    public void eat() {
        // 로봇은 식사를 하지 않음. 불필요한 구현이 필요함.
    }
}

```

### ISP 적용 예시

```java
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

class HumanWorker implements Workable, Eatable {
    public void work() {
        // 작업하는 코드
    }

    public void eat() {
        // 식사하는 코드
    }
}

class RobotWorker implements Workable {
    public void work() {
        // 작업하는 코드
    }
    // eat 메서드는 구현하지 않음. 로봇은 Eatable 인터페이스를 구현할 필요가 없음.
}

```

ISP를 적용한 예시에서는 **`Workable`**과 **`Eatable`**이라는 두 개의 인터페이스를 정의하여, 각 클래스가 실제로 필요로 하는 기능만을 구현하도록 했습니다. 이로써, 각 클라이언트(여기서는 **`HumanWorker`**와 **`RobotWorker`**)는 자신이 필요로 하는 메서드에만 의존하게 됩니다.

설계가 꼭 현실 세계를 반영할 필요는 없다는 것이다.
중요한 것은 설계가 반영할 도메인의 요구사항이고 그 안에서 클라이언트가 객체에 요구하는 행동이다.
현실을 정확하게 묘사하는 것이 아니라 요구사항을 실용적으로 수용하는 것을 목표로 삼아야 한다.

요구사항 속에서 클라이언트가 기대하는 행동에 집중하라는 것이다.

---

## 서브클래싱과 서브타이핑

상속이 두 가지 목적을 위해 사용된다는 사실을 이해하자.

1. 코드 재사용
2. 타입 계층 구성

사람들이 상속을 사용하는 두 가지 목적에 특별한 이름을 붙였는데 그것이 바로 서브클래싱/서브타이핑 이다.

자식 클래스가 부모 클래스의 코들르 재사용할 목적으로 상속을 사용헀다면 그것은 서브클래싱이다.

부모 클래스의 인스턴스 대신 자식 클래스의 인스턴스를 사용할 목적으로 상속을 사용했다면 그것은 서브타이핑이다.

즉, 어떤 타입이 다른 타입의 서브타입이 되기 위해서는 행동 호환성을 만족시켜야 한다.

자식 클래스가 부모 클래스가 사용되는 모든 문맥에서 자식 클래스와 동일하게 행동할 수 있어야 한다.
그리고 행동 호환성을 만족하는 상속관계는 부모 클래스를 새로운 자식 클래스로 대체하더라도 시스템이 문제없이 동작할 것이라는 것을 보장해야한다.

다시 말해, 자식과 부모 클래스 사이의 행동 호환성은 부모 클래스에 대한 자식 클래스의 **대체 가능성**을 포함한다.

---

# 리스코프 치환 원칙 - LSP

상속 관계로 연결한 두 클래스가 서브타이핑 관계를 만족시키기 위해서는 다음의 조건을 만족시켜야 한다.

서브타입은 그것의 기반 타입에 대해 대체가능해야 한다.

차이점을 인식하지 못한 채 기반 클래스의 인터페이스를 통해 서브클래스를 사용할 수 있어야한다. 이는 행동 호환성을 설계원칙으로 정리한 것이다.

리스코프 치환 원칙( LSP)은 소프트웨어 엔지니어링에서 객체 지향 프로그래밍의 설계 원칙 중 하나입니다.
LSP는 특히 상속을 사용할 때 중요한 지침을 제공합니다.

### **LSP의 정의**

리스코프 치환 원칙은 다음과 같이 정의할 수 있습니다.

"프로그램에서 부모 클래스의 인스턴스 대신에 자식 클래스의 인스턴스를 사용해도, 프로그램의 정확성을 변경하지 않고 동작해야 한다."

간단히 말해, 하위 클래스는 상위 클래스의 행동을 변경하지 않고 확장만을 수행해야 합니다. 즉, 하위 클래스는 상위 클래스와 동일한 방식으로 동작해야 하며, 클라이언트 입장에서는 상위 클래스인지 하위 클래스인지 구분 없이 사용할 수 있어야 합니다.

### **LSP의 중요성**

- **호환성 유지:** LSP를 준수하면, 상위 클래스의 참조를 사용하는 모든 곳에서 하위 클래스의 객체를 문제없이 사용할 수 있습니다. 이는 컴포넌트 간의 호환성을 보장합니다.
- **유지보수성 향상:** 클래스 계층을 변경하거나 확장해야 할 때, LSP를 지키면 기존 코드를 크게 변경하지 않고도 새로운 기능을 추가하거나 기존 기능을 개선할 수 있습니다.
- **재사용성 증가:** 잘 설계된 클래스 계층은 재사용이 용이합니다. LSP를 준수하면 상위 클래스를 재사용하는 다양한 컨텍스트에서 하위 클래스도 안전하게 재사용할 수 있습니다.

### **LSP 위반 예시**

```java
class Bird {
    void fly() {
        // 기본적인 비행 동작 구현
    }
}

class Penguin extends Bird {
    @Override
    void fly() {
        throw new UnsupportedOperationException("펭귄은 날 수 없습니다.");
    }
}
```

위의 예시에서 **`Penguin`** 클래스는 **`Bird`** 클래스를 상속받지만, **`fly`** 메서드를 오버라이드하여 날 수 없음을 나타냅니다. 이는 LSP를 위반하는 것으로, **`Bird`**의 인스턴스를 **`Penguin`**으로 대체했을 때 프로그램이 정상적으로 동작하지 않을 수 있습니다.

### **LSP 준수 예시**

LSP를 준수하기 위해선, **`Bird`**와 **`Penguin`**의 관계를 다르게 모델링해야 합니다. 예를 들어, 날 수 있는 특성을 인터페이스로 분리하고, 해당 인터페이스를 **`Bird`** 클래스가 아닌 날 수 있는 새들의 클래스에서 구현하도록 할 수 있습니다.

```java
interface FlyingBird {
    void fly();
}

class Sparrow extends Bird implements FlyingBird {
    @Override
    public void fly() {
        // 참새 비행 구현
    }
}

class Penguin extends Bird {
    // fly 메서드는 구현하지 않음. 펭귄은 FlyingBird 인터페이스를 구현하지 않으므로, 날 수 없는 것이 명확해짐.
}
```

이처럼 LSP는 타입 계층을 설계할 때 기본적으로 고려해야 하는 원칙으로, 프로그램의 정확성, 호환성, 유지보수성을 유지하는 데 중요한 역할을 합니다.

> 사실
정사각형과 직사각형의 상속 관계는 리스코프 치환 원칙을 위반하는 대표적이며 고전적인 사례 중 하나다.
> 

대체 가능성을 결정하는 것은 클라이언트다. 
→ 즉, 모든 클라이언트의 요구사항에 의존한다는 것이다.

is -a 관계 역시 행동이 우선이다.

---

디버깅 하는법을 숙지하시길 권장합니다. 

그래야 오류에 직면 했을 때 해결하기 쉬워집니다.

---

# 계약에 의한 설계와 서브 타이핑

게약에 의한 설계, 사전조건, 사후조건, 클래스 불변식 (461page)

> 서브 타입이 리스코프 치환 원칙을 만족시키기 위해서는 클라이언트와 슈퍼타입 간에 체결된 “계약”을 준수해야 한다.
> 

자식 클래스가 부모 클래스의 서브타입이 되기 위해서는 다음 조건을 만족시켜야 한다.

> 서브타입에 더 강력한 사전조건을 정의할 수 없다.
> 

클라이언트는 이미 자신의 의무를 충실히 수행하고 있기 떄문에 사전조건을 체크하지 않는 것이 기존 협력에 어떤 영향도 미치지 않는다. 이 경우엔 아무런 문제도 발생하지 않는 것이다.

따라서,

> 서브타입에 슈퍼타입과 같거나 더 약한 사전조건을 정의할 수 있다.
> 

만약, 사후조건을 강화한다면 ?

> 서브타입에 슈퍼타입과 같거나 더 강한 사후조건을 정의할 수 있다.
> 

만약, 사후조건을 약하게 정의한다면 ?

> 서브타입에 더 약한 사후조건을 정의할 수 있다.
> 

### 정리

상속은 타입 계츠응ㄹ 구현할 수 있는 전통적인 방법이지만 유일한 방법은 아니다.

상속을 사용하지 않고도 타입 계층을 구현할 수 있는 다양한 방법이 존재한다.
또한 타입과 타입 계층을 구현하는 방법은 사용하는 프로그래밍 언어나 타입 체크의 시점에 따라 달라질 수 있따.

(”부록 B, 타입 계층의 구현” 확인하면 나옴)
