# ch05 책임 할당하기

---

---

# 서론

4장에선, 데이터 중심의 설계는 행동보다 데이터를 먼저 결정하고 협력이라는 문맥을 벗어나 고립된 객체의 상태에 초점을 맞추기 때문에 캡슐화를 위반하기 쉽고, 요소들 사이의 결합도가 높아지며, 코드를 변경하기 어려워진다. 이러한 문제점들을 해결하기 위한 근본적인 방법은 데이터가 아닌 책임에 초점을 맞추는 것이다.

이제 객체에 책임을 할당하는 기본적인 원리를 살펴보자.

---

# 책임 주도 설계를 향해

책임중심 설계의 2가지 대원칙 

- 데이터보다 행동을 먼저 결정
- 협력이라는 문맥 안에서 책임을 결정

데이터가 아니라 객체의 책임과 협력에 초점을 맞추라는 것이다.

## 데이터보다 행동을 먼저 결정하라

외부에서 제공하는(이를 ‘의존성주입’이라고 함) 행동이 중요하다.

객체가 수행하는 행동이란 곧 객체의 책임을 의미한다.

데이터는 필요한 재료를 제공할 뿐이다.

우리에게 필요한 것은 “객체의 데이터에서 행동으로 무게 중심을 옮기기 위한 기법이다”.

→ 질문의 순서를 바꾸는 것이다.

반면, 책임 중심의 설계에서는 “이 객체가 수행해야 하는 책임은 무엇인가?”를 결정한 후에 “이 책임을 수행하는 데 필요한 데이터는 무엇인가”를 결정한다.

> 즉, 데이터가 아닌 객체의 행동에 초점을 맞추는 것 자체가 객체의 책임을 의미한다고 보면된다.
> 

## 협력이라는 문맥 안에서 책임을 결정하라

→ 적절한 객체에게 적절한 책임을 할당하게 된다.

협력에 적합한 정도로 결정한다 → 여기서 말하는 “적합한 정도”는 무엇일까?

→ 책임은 객체의 입장이 아니라 객체가 참여하는 협력에 적합해야 한다는 것이다.
→ 즉, 어색하냐. 이상하냐의 상태를 보다는 말인 것일까???

RDD의 책임을 결정할 때 "적합한 정도"를 고려한다는 것은, 객체가 참여하는 협력의 맥락에서 그 객체의 책임이 자연스럽고 효율적으로 느껴져야 한다는 의미이다.
즉, 책임이 객체의 기능이나 역할을 고려하여 협력 내에서 합리적으로 배분되어야 함을 의미한다.
여기서의 "적합한 정도"를 평가하는 기준은 아래와 같게 되는 것이다.

- **협력의 효율성**
객체가 맡은 책임이 협력을 보다 원활하게 만드는가? 즉, 협력의 전체적인 목표 달성에 기여하는가?
- **자연스러움과 명확성**
객체에 할당된 책임이 그 객체의 목적이나 역할과 자연스럽게 일치하는가? 책임이 그 객체에게 명확하고 이해하기 쉬운가?
- **재사용성과 유지보수성**
책임의 할당이 객체의 재사용성을 높이고 유지보수를 용이하게 하는가?
- **결합도와 응집도의 균형**
책임의 할당이 객체 간의 결합도를 낮추고 각 객체의 응집도를 높이는 방식으로 이루어지는가?

이렇게 책임이 객체에 할당될 때, 그 책임이 해당 객체의 성격과 역할에 부합하며, 협력 내에서의 다른 객체들과의 관계에서도 조화롭게 느껴져야 한다. 책임 중심 설계에서는 이러한 평가를 통해 객체가 협력 내에서 어떻게 행동해야 하는지 결정하게 된다.

사실상 이렇게 말로 엄청 풀어 쓰지만, 그냥 경험을 해봐야한다.

많은 코드를 작성해보고, 이게 객체지향적인 설계가 맞나 ? 라는 생각을해봐야한다. 
즉, 일단 경험을 해야한다. 일단 해보고, 경험을 통해서 일부 수정하면서 더 나아가야하는 것이다.

협력에 적합한 책임을 수행하기 위해서는 메시지를 결정한 후에 객체를 선택해야 한다.

> “이 클래스가 필요하다는 점은 알곘는데 이 클래스는 무엇을 해야 하지?”라고 질문하지 않고 “메시지를 전송해야 하는데 누구에게 전송해야 하지?”라고 질문하는 것.
→ 예) MVC 에서 Controller가 궁금한데, 이는 무엇을 하지? ⇒ 이를 메시지 기반으로 바꾼다면 ???
⇒ “ 객체를 가지고 있기 떄문에 메시지를 보내는 것이 아니다. 메시지를 전송하기 때문에 객체를 갖게된 것”
> 

객체를 결정하기 전에 객체가 수신할 메시지를 먼저 결정한다. 메시지를 수신하기로 결정된  객체는 메시지를 처리할 ‘책임’을 할당받게 된다.

데이터 중심 설게가 캡슐화에 취약한 반면 협력이라는 문맥 안에서 메시지에 집중하는 RDD는 캡슐화의 원리를 지키기가 훨 씬 시워진다.

## RDD - 책임 주도 설계

RDD의 핵심은 책임을 결정한 후에 책임을 수행할 객체를 결정하는 것이다.
협력에 참여하는 객체들의 책임이 어느정도 정리될 떄까지는 객체의 내부 상태에 대해 관심을 가지지 않는 것이다.

# 책임 할당을 위한 GRASP

GRASP - 일반적인 책임 할당 소프트웨어 패턴

중요한 것은 설계를 시작하는 것이지 도메인 개념들을 완벽하게 정리하는 것이 아니다.
***도메인 개념을 정리하는 데 너무 많은 시간을 들이지 말고 빠르게 설계와 구현을 진행하라.***

사실 앞으로도 패턴에 대해 정말 많은 내용이 해당 책에 나온다.
하지만, 나도 저자에게 동의하는 바가 있다.
패턴에 너무 얽매이고 싶지않다.

나는 아직 초보 개발자라고 생각한다. RDD 방법에 익숙하지 않다.
따라서 ***일단 data 중심으로 db 설계 및 도메인 설계를 하면서 구현한 후 이를 리팩토링하더라도 유사한 결과를 얻을 수 있다***. 이게 키 포인트다.

처음부터 RDD 방법을 따라는 것보다 동작하는 코드를 작성한 후에 리팩토링하는 것이 더 훌륭한 결과물을 낳을 수도 있다.

또한, 리팩토링 하면서 내가 설계한 코드에 대해 로직을 좀더 잘 이해할 수 있을 것이다.

“캡! 상추다”도 정말 중요한 내용이지만, 해당 챕터에선 캡슐화, 결합도, 응집도를 이해하고 훌륭한 객체지향 원칙을 적용하기 위해 노력한다면 RDD 방법을 단계적으로 따르지 않더라도 유연하고 깔끔한 아주 좋은 코드를 얻을 수 있을 것이다.

# 구현을 통한 검증

Screening이 Movie의 내부 구현에 대한 어떤 지식도 없이 전송할 메시지를 결정했다는 것이다.

## DiscountCondition 개선하기

객체 지향 설계 원칙 중 하나인 단일 책임 원칙(Single Responsibility Principle, SRP)에 따르면, 클래스는 단 한 가지 이유로만 변경되어야 합니다. **`DiscountCondition`** 클래스가 변경에 취약하다고 할 때, 이는 SRP를 위반하고 있음을 나타냅니다.

**`DiscountCondition`** 클래스는 할인 조건을 판단하는 로직을 담당합니다. 일반적으로 할인 조건에는 여러 유형이 있을 수 있습니다. 예를 들어, 영화 예매 시스템에서는 시간 조건(예: 평일 오후 1시부터 5시 사이에만 할인)과 순번 조건(예: 5번째 예매자, 10번째 예매자에게만 할인) 등 다양한 할인 조건이 있을 수 있습니다.

1. **새로운 할인 조건의 유형 추가**
새로운 할인 조건 유형이 도입되면, **`DiscountCondition`** 클래스에 그 조건을 판단하는 새로운 로직을 추가해야 합니다. 예를 들어, 특정 기간 동안의 할인, 회원 등급에 따른 할인 등 다양한 조건이 추가될 수 있습니다.
2. **할인 조건을 판단하는 로직 변경**
기존 할인 조건의 판단 로직이 변경될 경우, 예를 들어 시간 조건의 할인 시간대가 변경되거나, 순번 조건의 할인을 적용하는 순번이 변경될 경우 **`DiscountCondition`** 클래스를 수정해야 합니다.
3. **할인 조건의 평가 방식 변경 (기본 조건을 판단하는 로직이 변경되는 경우)**
할인을 적용하는 기준이 복잡해지거나 다른 방식으로 평가해야 할 필요가 생기면, **`DiscountCondition`** 클래스의 구조 자체를 변경해야 할 수 있습니다. 예를 들어, 여러 할인 조건을 조합하여 할인 여부를 결정하는 경우 등이 이에 해당할 수 있습니다.

이러한 다양한 변경 이유들은 **`DiscountCondition`** 클래스가 단일 책임 원칙을 위반하고 있음을 시사합니다. 각각의 할인 조건 유형이나 로직을 별도의 클래스로 분리하여 관리하는 것이 이상적입니다. 이를 통해 각 할인 조건을 독립적으로 관리할 수 있게 되며, 새로운 할인 조건의 추가나 기존 조건의 변경이 발생했을 때 해당하는 부분만 수정함으로써 전체 시스템의 유연성과 확장성을 높일 수 있습니다.

## 변경과 유연성

1. 단순하게 설계
2. 코드를 더 유연하게 만들기
전자가 더 좋은 방법이지만 유사한 변경이 반복적으로 발생하고 있다면 복잡성이 상승하더라도 유연성을 추가하는 두 번쨰 방식이 더 좋다.

## 상속대신 *합성* 사용

# 책임 주도 설계의 대안

개인적으로 책임과 객체 사이에서 방황할 때 돌파구를 찾기 위해 선택하는 방법은 **최대한 빠르게 목적한 기능을 수행하는 코드를 작성하는 것이다**.

일단 실행되는 코드를 얻고 난 후에 코드 상에 명확하게 드러나는 책임들을 올바른 위치로 이동시키는 것이다.

> 즉, 해당 기능이 돌아가게끔 구현하고, 책임들을 올바른 위치로 수정하는 “ 리팩토링 “을 권장한다.
> 

### 메서드 응집도

몬스터 메서드 = 긴 메서드를 말함 → 응집도 낮음

즉, 짧고 이해하기 쉬운 이름으로 된 메서드를 좋아한다.

중요한 것은 길이보다 메서드의 이름과 메서드 몸체의 의미적 차이다.

reserve 메서드가 수정된 167,169 비교해서 보면 좋다.

## 객체를 자율적으로 만들자

자신이 소유하고 있는 데이터를 자기 스스로 처리하도록 만드는 것이 자율적인 객체를 만드는 지름길이다.
