# ch12 다형성

---

---

# 서론

코드 재사용을 목적으로 상속을 사용하면 변경하기 어렵고 유연하지 못한 설계에 이를 확률이 높아진다.
상속은 타입 계층을 구조화하기 위해 사용해야 한다.

<aside>
❓ Q. 
여기서 중요한 것은 “타입 계층을 구조화하기 위해서”라고 했는데 타입계층 구조화는 어떻게 하는거고, 어떤 의미인거지?

A.

타입 계층을 구조화한다는 것은 객체 지향 프로그래밍에서 매우 중요한 개념입니다. 
이는 클래스들 간의 관계를 명확하게 정의하고, 이를 통해 코드의 재사용성과 유지보수성을 높이는 방법을 의미합니다. 
타입 계층 구조화는 주로 상속과 인터페이스를 통해 이루어집니다.
상속을 사용하면 하위 클래스가 상위 클래스의 속성과 메소드를 재사용할 수 있으며, 
인터페이스를 통해서는 구현을 강제하여 다형성을 실현할 수 있습니다.

다형성은 같은 인터페이스나 기본 클래스를 공유하는 다양한 객체들이 그 인터페이스나 클래스에 정의된 메소드를 다른 방식으로 실행할 수 있도록 하는 객체 지향 프로그래밍의 특징입니다. 
이를 통해 다양한 타입의 객체를 동일한 방식으로 처리할 수 있게 됩니다.

### **예시**

다음 예시에서는 타입 계층 구조화와 다형성을 보여주는 간단한 Java 코드를 살펴보겠습니다. 이 예시에서는 동물을 나타내는 기본 클래스 **`Animal`**과 이를 상속받는 두 하위 클래스 **`Dog`**와 **`Cat`**을 정의합니다. 또한, 이들 모두가 **`speak`** 메소드를 다르게 구현함으로써 다형성을 실현합니다.

```java
// 기본 클래스
class Animal {
    void speak() {
        System.out.println("This animal speaks in a way unique to its species.");
    }
}

// Dog 클래스는 Animal 클래스를 상속받습니다.
class Dog extends Animal {
    @Override
    void speak() {
        System.out.println("Woof");
    }
}

// Cat 클래스는 Animal 클래스를 상속받습니다.
class Cat extends Animal {
    @Override
    void speak() {
        System.out.println("Meow");
    }
}

// 메인 클래스와 메인 메소드
public class Main {
    public static void main(String[] args) {
        Animal myDog = new Dog();
        Animal myCat = new Cat();

        // 동적 바인딩을 통해 실행 시점에 각 객체의 speak 메소드가 호출됩니다.
        myDog.speak(); // 출력: Woof
        myCat.speak(); // 출력: Meow

        // 배열을 사용하여 다형성을 더 쉽게 볼 수 있습니다.
        Animal[] animals = {new Dog(), new Cat()};
        for(Animal animal : animals) {
            animal.speak(); // 동적으로 올바른 메소드가 호출됩니다.
        }
    }
}

```

이 예시에서 **`Animal`** 클래스는 타입 계층의 최상위에 위치하며, **`Dog`**와 **`Cat`** 클래스는 이를 상속받아 **`speak`** 메소드를 각자의 방식으로 구현합니다. 
이를 통해, **`Dog`**와 **`Cat`** 객체를 **`Animal`** 타입으로 처리할 수 있으며, 실행 시간에 **`Animal`** 참조를 통해 실제 객체의 **`speak`** 메소드가 호출됩니다. 
이런 방식으로 타입 계층을 구조화하고 다형성을 활용하면, 코드의 재사용성과 유지보수성이 크게 향상됩니다.

</aside>

### 상속을 활용해 자식 클래스를 추가하려 한다면 스스로에게 질문을 해보길 권장한다.

1. 상속을 사용하려는 목적이 코드 재사용인가 ?
2. 클라이언트 관점에서 인스턴스들을 동일하게 행동하는 그룹으로 묶기 위해서인가 ? (그룹화)

초기에 상속은 타입 계층과 다형성을 구현할 수 있는 거의 유일한 방법이었다.
이에 상속에 대한 맹신 추종이 자라났다.
하지만 여전히 상속은 다형성을 구현할 수 있는 가장 일반적인 방법이다.

하지만 상속 이외에도 다형성을 구현할 수 있는 다양한 방법들을 제공하고 있다.

그럼, 어떤 다양한 방법들이 있는 것일까??

1. **인터페이스(Interface)**
인터페이스는 메서드의 시그니처만을 선언하는데, 구현 클래스는 인터페이스에 선언된 모든 메서드를 구현해야 합니다. 이 방법을 통해 다양한 클래스들이 같은 인터페이스를 구현함으로써 다형성을 실현할 수 있습니다. 인터페이스를 사용하면 클래스는 여러 인터페이스를 구현할 수 있으므로, 단일 상속의 제약에서 벗어날 수 있습니다.
2. **추상 클래스(Abstract Class)**
추상 클래스를 사용하면 몇몇 메서드는 구현하고, 나머지 메서드는 서브 클래스에서 구현하도록 남겨둘 수 있습니다. 이 방식은 추상 클래스를 상속받는 서브 클래스들이 다형성을 가지도록 할 수 있습니다.
3. **컴포지션(Composition)**
컴포지션은 "has-a" 관계를 통해 다형성을 실현합니다. 
예를 들어, 특정 클래스가 다양한 행동을 가진 객체를 필드로 가질 수 있으며, 이 객체는 모두 같은 인터페이스를 구현합니다. 이를 통해 실행 시간에 다른 객체를 주입하여 다양한 행동을 실현할 수 있습니다.
4. **전략 패턴(Strategy Pattern)**
전략 패턴은 알고리즘의 일부분을 런타임에 교체할 수 있도록 해줍니다. 
이 패턴을 사용하면 컨텍스트(사용하는 객체)는 전략 객체(알고리즘을 구현한 객체)를 바꿔 끼워 넣음으로써 다양한 작업을 수행할 수 있습니다. 
모든 전략 객체는 동일한 인터페이스를 구현하므로 다형성을 실현할 수 있습니다.
5. **델리게이션(Delegation)**
 델리게이션은 특정 작업을 다른 객체에 위임하는 방식을 말합니다. 
이를 통해 다양한 객체들이 다형성을 실현할 수 있으며, 상속을 사용하지 않고도 코드 재사용성을 높일 수 있습니다.

<aside>
👉 다형성이 런타임에 메시지를 처리하기에 적합한 메서드를 동적으로 탐색하는 과정을 통해 구현되며,
상속이 이런 메서드를 찾기 위한 일종의 탐색 경로를 클래스 계층의 형태로 구현하기 위한 방법이다.

</aside>

---

# 다형성

‘많은 형태를 가질 수 있는 능력’

간단하게 말해, 여러 타입을 대상으로 동작할 수 있는 코드를 작성할 수 있는 방법이다.

**다형성의 분류**

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/075997f4-35b2-4955-b621-060d6a108880/cd5916b3-2e86-46e7-910c-7f937577253a/Untitled.heic)

- **오버로딩 다형성 :** 하나의 클래스 안에 동일한 이름의 메서드가 존재하는 경우 
클래스 안에 서로 다른 타입의 파라미터를 받아 처리하는 메서드들이 동일한 이름을 가지는 경우가 오버로딩에 해당한다.
유사한 작업을 수행하는 메서드의 이름을 통일할 수 있기 때문에 기억해야 하는 이름의 수를 극적으로 줄일 수 있다는 장점이 있다.
- **강제 다형성** : 언어가 지원하는 자동적인 타입 변환이나 사용자가 직접 구현한 타입 변환을 이용해 동일한 연산자를 다양한 타입에 사용할 수 있는 방식을 가리킨다.
- **매개변수 다형성** : **제네릭 프로그래밍**과 관련이 높은데, 클래스의 인스턴스 변수나 메서드의 매개변수 타입을 임의의 타입으로 선언한 후 사용하는 시점에 구체적인 타입으로 지정하는 방식을 가리킨다.
예를 들어, 자바의 List 인터페이스는 컬렉션에 보관할 요소의 타입을 임의의 타입 T로 지정하고 있으며,
실제 인스턴스를 생성하는 시점에 T를 구체적인 타입으로 지정할 수 있게 하고 있다.
따라서, List 인터페이스는 다양한 타입의 요소를 다루기 위해 동일한 오퍼레이션을 사용할 수 있따.
- **포함 다형성 = 서브타입 다형성** : 메시지가 동일하더라도 수신한 객체의 타입에 따라 실제로 수행되는 행동이 달라지는 능력을 의미한다.

포함 다형성을 구현하는 가장 일반적인 방법은 상속을 사용하는 것이다.

두 클래스를 상속 관계로 연결하고 자식 클래스에서 부모 클래스의 메서드를 오버라이딩한 후 클라이언트는 부모 클래스만 참조하면 포함 다형성을 구현할 수 있다.

```java
// 부모 클래스
class Animal {
    void speak() {
        System.out.println("This animal speaks in a generic way.");
    }
}

// Dog 클래스는 Animal 클래스를 상속받습니다.
class Dog extends Animal {
    @Override
    void speak() {
        System.out.println("Woof");
    }
}

// Cat 클래스는 Animal 클래스를 상속받습니다.
class Cat extends Animal {
    @Override
    void speak() {
        System.out.println("Meow");
    }
}

public class PolymorphismExample {
    public static void main(String[] args) {
        // Animal 타입의 참조변수로 Dog 객체를 참조
        Animal myDog = new Dog();
        // Animal 타입의 참조변수로 Cat 객체를 참조
        Animal myCat = new Cat();
        
        // 부모 클래스 타입으로 자식 클래스의 메서드 호출 (다형성)
        myDog.speak(); // 출력: Woof
        myCat.speak(); // 출력: Meow
        
        // 다형성을 활용한 배열 예제
        Animal[] animals = {new Dog(), new Cat()};
        for(Animal animal : animals) {
            animal.speak(); // 각 객체의 speak 메서드가 동적으로 호출됩니다.
        }
    }
}

```

***상속의 진정한 목적은 코드 재사용이 아니라 다형성을 위한 서브타입 계층을 구축하는 것이다.***

상속의 일차적인 목적이 코드 재사용이 아닌 서브타입의 구현이라는 사실을 이해하는 것만으로도 충분하다.

이번 챕터에서는 다형성의 다양한 측면 중에서도 포함 다형성에 관해 중점적으로 다룬다.
포함 다형성의 관점에서 런타임에 상속 계층 안에서 적절한 메서드를 선택하는 방법을 이해하는 것이다.

---

# 상속의 양면성

객체지향 패러다임의 근간은 ‘데이터와 행동을 객체라고 불리는 하나의 실행 단위 안으로 통합하는 것’이다.

- **데이터 관점의 상속** : 상속을 이용하면 부모 클래스에서 정의한 모든 데이터를 자식 클래스의 인스턴스에 자동으로 포함시킬 수 있다.
- **행동 관점의 상속** : 데이터 뿐만 아니라 부모 클래스에서 정의한 일부 메서드 역시 자동으로 자식 클래스에 포함시킬 수 있다.

상속은 다형성을 가능하게 하는 타입 게층을 구축하기 위한 것이다.

## *상속의 메커니즘*

- 업캐스팅
- 동적 메서드 탐색
- 동적 바인딩
- self 참조
- super 참조

### **1. 업캐스팅 (Upcasting)**

업캐스팅은 자식 클래스 타입의 객체를 부모 클래스 타입으로 변환하는 과정입니다. 이는 항상 안전하며, 자동으로 이루어집니다. 업캐스팅을 통해 부모 클래스 타입의 참조변수로 자식 클래스의 인스턴스를 참조할 수 있습니다.

```java

class Animal {
    void speak() {
        System.out.println("This animal speaks in a generic way.");
    }
}

class Dog extends Animal {
    @Override
    void speak() {
        System.out.println("Woof");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog();
        Animal myAnimal = myDog; // 업캐스팅
        myAnimal.speak(); // 출력: Woof
    }
}

```

### **2. 동적 메서드 탐색 (Dynamic Method Lookup)**

자바에서 객체의 메서드를 호출할 때, JVM(Java Virtual Machine)은 객체의 실제 타입을 확인하고 해당 타입에 맞는 메서드를 실행합니다. 이 과정이 동적 메서드 탐색입니다.

```java

// 위의 Animal과 Dog 클래스를 사용
public class Main {
    public static void main(String[] args) {
        Animal myAnimal = new Dog(); // 업캐스팅
        myAnimal.speak(); // 동적 메서드 탐색을 통해 Dog의 speak 메서드가 호출됩니다.
    }
}

```

### **3. 동적 바인딩 (Dynamic Binding)**

동적 바인딩은 프로그램 실행 중에 메서드 호출에 대한 코드를 결정하는 프로세스입니다. 자바에서는 객체의 실제 타입에 기반하여 어떤 메서드를 호출할지 결정합니다. 동적 바인딩은 동적 메서드 탐색을 통해 이루어집니다.

### **4. self 참조**

자바에서 **`this`** 키워드는 현재 객체를 가리키는 데 사용됩니다. 즉, 객체 내부에서 자신의 변수나 메서드에 접근할 때 사용합니다.

```java

class Animal {
    void introduce() {
        System.out.println("I am an animal.");
    }
    void speak() {
        this.introduce(); // self 참조를 사용하여 현재 객체의 다른 메서드 호출
        System.out.println("This animal speaks in a generic way.");
    }
}

```

### **5. super 참조**

**`super`** 키워드는 부모 클래스의 객체를 가리키는 데 사용됩니다. 자식 클래스에서 부모 클래스의 메서드나 변수에 접근할 때 사용합니다.

```java

class Animal {
    void speak() {
        System.out.println("This animal speaks in a generic way.");
    }
}

class Dog extends Animal {
    @Override
    void speak() {
        super.speak(); // 부모 클래스의 speak 메서드 호출
        System.out.println("Woof");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog myDog = new Dog();
        myDog.speak(); // 출력: This animal speaks in a generic way. Woof
    }
}
```

**super**의 정확한 의미에 관해 설명할 때까지는 super가 부모 클래스를 가리키도록 설정된 변수라는 정도만 이해.
일반적으로 super는 자식클래스 내부에서 부모 클래스의 인스턴스 변수나 메서드에 접근하는 데 사용된다.

**메서드 오버라이딩** : 자식 클래스 안에 상속받은 메서드와 동일한 시그니처의 메서드를 재정의해서 부모 클래스의 구현을 새로운 구현으로 대체하는 것

**메서드 오버로딩** : 부모 클래스에서 정의한 메서드와 이름은 동일하지만 시그니처는 다른 메서드를 자식 클래스에 추가하는 것

---

## 행동 관점의 상속

- 데이터 관점의 상속 : 자식 클래스의 인스턴스 안에 부모 클래스의 인스턴스를 포함하는 개념
- 행동 관점의 상속 : 부모 클래슥 ㅏ정의한 일부 메서드를 자식 클래스의 메서드로 포함시키는 것

외부의 객체가 부모 클래스의 인스턴스에게 전송할 수 있는 모든 메시지는 자식 클래스의 인스턴스에게도 전송할 수 있다.

부모 클래스에서 구현한 메서드를 자식 클래스의 인스턴스에서 수행할 수 있는 것일까???
→ 런타임에 시스템이 자식 클래스에 정의되지 않은 메서드가 있을 경우 이 메서드를 부모 클래스 안에서 탐색하기 때문이다.

메서드 탐색 과정을 이해하는 것이 가장 중요하다.

행동 관점의 상속을 이해하는 데 유용한 객체와 클래스 사이의 관계에 초점을 맞추도록 하자.

- 객체의 경우: 서로 다른 상태를 저장할 수 있도록 각 인스턴스별로 독립적인 메모리를 할당받아야 한다.
- 메서드의 경우 : 동일한 클래스의 인스턴스끼리 공유가 가능하기 때문에 클래스는 한 번만 메모리에 로드하고 각 인스턴스별로 클래스를 가리키는 포인터를 갖게 하는 것이 경제적이다.

인스턴스는 두 개가 생성됐지만 클래스는 단 하나만 메모리에 로드됐다는 사실에 주목하자 !
→ 특정 클래스로부터 여러 개의 객체(인스턴스)가 생성될 수 있지만, 그 클래스 자체의 정의는 메모리에 단 한 번만 존재한다는 것을 의미합니다.

### 다시 말해,

<aside>
❓

### **객체와 클래스의 관계**

- **객체(인스턴스):** 객체는 클래스에 의해 정의된 구조로 생성된 실체입니다. 각 객체는 메모리에 독립적인 공간을 할당받아 개별적인 상태(데이터)를 가집니다. 예를 들어, **`Dog`** 클래스로부터 생성된 각각의 **`Dog`** 객체는 서로 다른 이름, 나이 등의 속성 값을 가질 수 있습니다.
- **클래스:** 클래스는 객체를 생성하기 위한 템플릿이나 설계도 역할을 합니다. 클래스는 메서드(행동)와 변수(상태)의 정의를 포함하지만, 실제 데이터(상태의 값)는 인스턴스(객체)에 속합니다. 클래스 자체는 한 번만 메모리에 로드되며, 이 클래스를 기반으로 생성된 모든 인스턴스는 메모리 내의 이 클래스 정보를 공유합니다.

### **행동 관점의 상속**

행동 관점에서 볼 때, 상속은 부모 클래스에 정의된 메서드들이 자식 클래스에 자동으로 "포함"되는 것을 의미합니다. 이는 자식 클래스의 인스턴스가 부모 클래스에 정의된 메서드를 호출할 수 있음을 의미합니다. 만약 자식 클래스에서 해당 메서드가 오버라이드되지 않았다면, 부모 클래스의 메서드 구현이 사용됩니다.

### **메서드 공유와 인스턴스의 독립성**

객체 지향 프로그래밍에서, 클래스는 메모리에 한 번만 로드되고, 이 클래스의 모든 인스턴스는 해당 클래스의 메서드를 공유합니다. 이것은 메모리 사용을 효율적으로 만듭니다. 각 인스턴스는 자신만의 상태(예: 변수 값)를 가지고 있지만, 메서드 코드는 모든 인스턴스 간에 공유됩니다.

이 구조는 다음과 같은 이점을 제공합니다.

1. **메모리 효율성:** 모든 인스턴스가 메서드 코드를 공유하므로, 같은 클래스의 여러 인스턴스가 생성되더라도, 메서드 코드는 메모리에 단 한 번만 존재합니다. 각 인스턴스는 상태를 저장하기 위한 고유한 메모리 공간을 필요로 하지만, 행동(메서드)은 공유됩니다.
2. **다형성의 구현:** 자식 클래스의 인스턴스는 부모 클래스에 정의된 메서드를 호출할 수 있습니다. 만약 자식 클래스에서 해당 메서드를 오버라이드했다면, 해당 인스턴스는 오버라이드된 버전의 메서드를 사용합니다. 이 메커니즘은 런타임에 메서드가 동적으로 결정되도록 하여 다형성을 가능하게 합니다.

### **예시**

```java
class Animal {
    void eat() {
        System.out.println("This animal eats food.");
    }
}

class Dog extends Animal {
    @Override
    void eat() {
        System.out.println("Dog eats dog food.");
    }
}

public class Example {
    public static void main(String[] args) {
        Animal myAnimal = new Animal(); // Animal 인스턴스 생성
        Animal myDog = new Dog(); // Dog 인스턴스 생성, 업캐스팅으로 Animal 타입으로 참조

        myAnimal.eat(); // "This animal eats food."
        myDog.eat(); // "Dog eats dog food."
    }
}

```

이 예에서 **`Animal`** 클래스의 메서드 **`eat`**은 **`Dog`** 클래스에서 오버라이드됩니다. **`Dog`** 클래스의 인스턴스인 **`myDog`**는 **`Animal`** 타입으로 참조되지만, **`eat`** 메서드를 호출하면 **`Dog`** 클래스에서 오버라이드된 **`eat`** 메서드가 실행됩니다. 이는 메서드 호출이 실행 시간에 결정되며(동적 바인딩), 상속을 통해 행동의 다형성이 구현됨을 보여줍니다.

</aside>

자식 클래스의 인스턴스를 통해 어떻게 부모 클래스에 정의된 메서드를 실행할 수 있는지 ?

자식 클래스에서 부모 클래스로의 메서드 탐색이 간으하기 때문에, 각 객체에 포함된 class 포인터와 클래스에 포함된 포인터를 조합하면 현재 인스턴스의 클래스에서 최상위 부모 클래스에 이르기까지 모든 부모 클래스에 접근하는 것이 가능하다.

---

# 업캐스팅과 동적 바인딩

제일 중요한 것은 업캐스팅으로 인해 미래의 자식 클래스들도 협력에 참여할 수 있게 된다는 것이다.

### **업캐스팅**

업캐스팅은 자식 클래스 타입의 객체를 부모 클래스 타입의 참조로 다루는 것을 의미합니다. 이 과정은 자동으로 이루어지며, 타입 캐스팅의 한 형태입니다. 업캐스팅을 통해, 부모 클래스 타입의 변수를 사용하여 자식 클래스의 객체를 참조할 수 있습니다.

### 코드 예시

```java
class Animal {
    void speak() {
        System.out.println("This animal speaks in a generic way.");
    }
}

class Dog extends Animal {
    @Override
    void speak() {
        System.out.println("Dog says: Woof!");
    }
}

public class Main {
    public static void main(String[] args) {
        Dog dog = new Dog(); // Dog 객체 생성
        Animal animal = dog; // 업캐스팅: Dog 타입을 Animal 타입으로 참조
        animal.speak(); // 출력: Dog says: Woof!
    }
}
```

이 예제에서 **`Dog`** 클래스는 **`Animal`** 클래스를 상속받습니다. **`main`** 메서드 내에서 **`Dog`** 객체를 생성한 후, 이를 **`Animal`** 타입의 참조변수 **`animal`**로 참조합니다. 이 과정에서 업캐스팅이 자동으로 이루어집니다.

### **동적 바인딩 (Dynamic Binding)**

동적 바인딩은 프로그램 실행 중에 메서드 호출에 대한 구현을 결정하는 프로세스입니다. 자바에서는 메서드 오버라이딩이 발생하면, 컴파일 타임이 아닌 런타임에 객체의 실제 타입을 기반으로 호출할 메서드를 결정합니다. 이것이 동적 바인딩의 핵심입니다.

### 코드 예시를 통한 설명

위의 코드 예제에서 **`animal.speak();`**를 호출했을 때, 컴파일러는 **`Animal`** 타입의 **`speak`** 메서드를 호출하는 코드를 보게 됩니다. 그러나 실행 시, JVM(Java Virtual Machine)은 **`animal`** 참조변수가 실제로 가리키는 객체의 타입이 **`Dog`**임을 확인하고, **`Dog`** 클래스에 오버라이드된 **`speak`** 메서드를 실행합니다. 이것이 바로 동적 바인딩입니다.

업캐스팅과 동적 바인딩을 함께 사용함으로써, 자바에서는 타입 안전성을 유지하면서도 런타임에 다형성을 실현할 수 있습니다. 이러한 메커니즘 덕분에, 상위 클래스 타입의 참조를 통해 다양한 하위 클래스 객체들의 메서드를 호출할 수 있게 되어, 코드의 재사용성과 유연성이 크게 향상됩니다.

---

동적 메서드 탐색과 다형성에 대해 깊이 있게 이해하기 위해서는 몇 가지 핵심적인 객체 지향 프로그래밍의 개념들을 더 자세히 살펴보아야 합니다. 이 개념들은 객체 간의 상호작용, 메서드 호출의 실행 시점 결정, 상속과 위임의 관계를 이해하는 데 중요합니다.

### **동적 메서드 탐색 원리**

동적 메서드 탐색은 객체가 메서드 호출을 받았을 때, 해당 객체의 클래스에서부터 시작하여 상위 클래스로 이어지는 상속 계층을 따라 메서드를 탐색하는 과정입니다. 이 탐색 과정은 두 가지 중요한 특성을 기반으로 합니다:

1. **자동적인 메시지 위임:** 자식 클래스에서 처리할 수 없는 메서드 호출(메시지)을 받은 경우, 자동으로 해당 메시지를 상위 클래스로 위임합니다. 이는 클래스가 메서드를 명시적으로 구현하고 있지 않아도, 상속 계층을 통해 메서드를 찾을 수 있음을 의미합니다.
2. **동적인 문맥:** 메서드 호출이 발생했을 때, 해당 호출이 실제로 어떤 메서드에 의해 처리될지는 실행 시점에 결정됩니다. 메서드를 탐색하는 과정은 **`self`** 참조를 통해 현재 메시지를 수신한 객체의 실제 타입을 기반으로 시작됩니다.

### **self 대 super**

- **self 참조:** **`self`** 참조는 현재 메서드를 호출한 객체를 가리킵니다. **`self`**를 사용한 메서드 호출은 객체의 실제 타입에 기반하여 동적으로 메서드를 탐색합니다. 이는 다형성을 가능하게 하는 핵심 메커니즘입니다. **`self`** 참조는 메시지를 수신한 객체, 즉 메서드 호출이 일어난 현재 객체의 컨텍스트에서 메서드를 탐색합니다.
- **super 참조:** **`super`** 참조는 현재 객체의 부모 클래스의 컨텍스트에서 메서드를 탐색하는 데 사용됩니다. **`super`**를 사용한 메서드 호출은 현재 클래스의 바로 상위 부모 클래스에서부터 메서드 탐색을 시작하며, 현재 클래스에서 오버라이드된 메서드를 건너뛰고 부모 클래스의 구현을 호출합니다.

### **상속 대 위임**

- **상속과 self 참조:** 상속을 사용할 때, 자식 클래스의 인스턴스는 부모 클래스의 인스턴스와 동일한 **`self`** 참조를 공유합니다. 이는 상속 계층 내에서 메서드를 탐색할 때, 모든 클래스가 하나의 실행 컨텍스트를 공유한다는 것을 의미합니다.
- **위임:** 위임은 객체가 특정 작업을 다른 객체에게 맡기는 패턴을 말합니다. 이 경우, 객체는 다른 객체의 메서드를 직접 호출하여 작업을 수행하게 합니다. 위임을 통해, 상속 없이도 객체 간의 관계를 유연하게 구성할 수 있으며, 복잡한 상속 구조의 대안으로 사용될 수 있습니다.

동적 메서드 탐색과 다형성은 객체 지향 프로그래밍에서 객체의 행동과 상호작용의 복잡성을 관리하기 위한 핵심적인 메커니즘입니다. 이러한 개념을 통해, 개발자는 실행 시점에 객체의 실제 타입에 따라 적절한 메서드를 선택하고 호출할 수 있는 유연하고 동적인 시스템을 구축할 수 있습니다.
