# 📕 [Object] 3장. 객체지향 프로그래밍

객체지향 패러다임의 관점에서 핵심은 **역할(role)**, **책임(responsibility)**, **협력(collaboration)**이다.
클래스, 상속, 지연 바이딩이 중요하지 않은 것은 아니지만 다분히 구현 측면에 치우쳐 있기 때문에 객체지향 패러다임의 본질과는 거리가 멀다.

객체지향의 본질은 협력하는 객체들의 공동체를 창조하는 것이다. 객체지향 설계의 핵심은 협력을 구성하기 위해 적절한 객체를 찾고 적절한 책임을 할당하는 과정에서 드러난다.

# ⭐️ 협력
![](https://velog.velcdn.com/images/pp8817/post/22cfcacc-e9d6-4597-a254-79eae482b488/image.png)
위 그림에서 알 수 있는 것처럼 객체지향 원칙을 따르는 애플리케이션의 제어 흐름은 어떤 하나의 객체에 의해 통제되지 않고 다양한 객체들 사이에 균형 있게 분배되는 것이 일반적이다.

객체들이 애플리케이션의 기능을 구현하기 위해 수행하는 상호작용을 **협력**이라고 한다.
객체가 협력에 참여하기 위해 수행하는 로직은 **책임**이라고 부른다.
객체들이 협력 안에서 수행하는 책임들이 모여 객체가 수행하는 **역할**을 구성한다.

- - -
객체지향 시스템은 자율적인 객체들의 공동체다. 객체는 고립된 존재가 아니라 시스템의 기능이라는 더 큰 목표를 달성하기 위해 다른 객체와 협력하는 사회적인 존재다. 고로 **협력**은 객체지향의 세계에서 기능을 구현할 수 있는 유일한 방법이다.

협력을 위한 두 객체 사이의 **메시지 전송(message sending)**은 객체 사이의 협력을 위해 사용할 수 있는 유일한 커뮤니케이션 수단이다.

메시지를 수신한 객체는 **메서드(Method)**를 실행해 요청에 응답한다. 여기서 객체가 메시지를 처리할 방법을 스스로 선택한다는 점이 중요하다.

**예시**
```
Screening --- calcuateMovieFee(Screening) ---> Movie
```
Screening 객체가 Movie에게 calculateMovieFee 메시지를 전송함 으로써 Movie에게 요금 계산을 요청한다.
이는 Movie가 요금 계산을 하는데 필요한 정책, 요금 등을 잘 알고 있기때문에 처리를 위임한 것이다.
이렇게 자신이 할 수 없는 일을 다른 객체에게 위임하면 협력에 참여하는 객체들의 전체적인 자율성을 향상 시킬 수 있다.

결과적으로 객체를 자율적으로 만들려면 내부 구현을 **캡슐화** 해야한다.
캡슐화를 하면 변경에 대한 파급효과를 제한할 수 있기 때문에 자율적인 객체는 변경하기도 쉬워진다.
Screening이 요금을 계산하기 위해 Movie의 내부에 직접적으로 접근하는 것은 **캡슐화의 원칙을 위반**하는 것이다. 반면, calculateMovieFee와 같이 메시지를 사용하면 되면, Screening과 Movie 사이의 결합도를 느슨하게 유지할 수 있다.

객체의 상태는 그 객체가 행동을 수행하는데 필요한 정보가 무엇인지로 결정된다. 즉, 객체의 상태를 결정하는 것은 **행동**이다.

**협력 -> 행동 -> 상태**로 이해 객체가 참여하는 협력이 객체를 구성하는 행동과 상태 모두를 결정한다.
결과적으로 협력은 객체를 설계하는데 필요한 일종의 **문맥(Contecxt)**을 제공한다.


# ⭐️ 책임
협력에 참여하기 위해 객체가 수행하는 행동을 **책임**이라고 부른다.

책임이란 객체에 의해 정의도니느 응집도 있는 행위의 집합으로, 객체가 유지해야 하는 정보와 수행할 수 있는 행동에 대한 개략저그올 서술한 문장이다.

즉, 객체의 책임
-  객체가 '무엇을 알고 있는가'
    - 사적인 정보에 관해 아는 것
    - 관련된 객체에 관해 아는 것

    - 자신이 유도하거나 계산할 수 있는 것에 관해 아는 것
- 객체가 '무엇을 할 수 있는가'
    - 객체를 생성하거나 계산을 수행하는 등의 스스로 하는 것

    - 다른 객체의 행동을 시작시키는 것
    - 다른 객체의 활동을 제어하고 조절하는 것

영화 예매 시스템에서 Screening의 책임?
-> 영화를 예매하는 것

Movie의 책임?
-> 요금을 계산하는 것

협력 안에서 객체에게 할당한 _책임이 외부의 인터페이스와 내부의 속성을 결정하게 된다._

일반적으로 책임과 메시지의 크기는 다르다. 책임은 객체가 수행할 수 있는 행동을 종합적이고 간략하게 서술하기 때문에 메시지보다 추상적이고 개념적으로도 더 크다.

**중요한 사실**
책임의 관점에서 '아는 것'과 '하는 것'이 밀접하게 연관돼 있다는 점이다. 객체는 자신이 맡은 책임을 수행하는 데 필요한 정보를 알고 있을 책임이 있다. 또한 객체는 자신이 할 수 없는 작업을 도와 줄 객체를 알고 있을 책임이 있다.
어떤 책임을 수행하기 위해서는 그 책임을 수행하는 데 필요한 정보도 함께 알아야 할 책임이 있는 것이다.

책임은 객체지향 설계의 **핵심**이다. 사실 협력이 중요한 이유는 객체에게 할당할 책임을 결정할 수 있는 문맥을 제공하기 때문이다. 적절한 협력이 적절한 책임을 제공하고, 적절한 책임을 적절한 객체에게 할당해야만 단순하고 유연한 설계를 창조할 수 있다.


## 📌 책임 주도 설계
지금까지 내용의 핵심은 **협력을 설계하기 위해서는 책임에 초점을 맞춰야 한다**는 것이다.
이처럼 책임을 찾고 책임을 수행할 적절한 객체를 찾아 책임을 할당하는 방식으로 설계하는 방법을 **책임 주도 설계(Responsibility-Driven Design, RDD)**라고 한다.

**책임 주도 설계 방법의 과정**
- 시스템이 사용자에게 제공해야 하는 기능인 시스템 책임을 파악한다.
- 시스템 책임을 더 작은 책임으로 분할한다.
- 분할된 책임을 수행할 수 있는 적절한 객체 또는 역할을 찾아 책임을 할당한다.
- 객체가 책임을 수행하는 도중 다른 객체의 도움이 필요한 경우 이를 책임질 적절한 객체 또는 역할을 찾는다.
- 해당 객체 또는 역할에게 책임을 할당함으로써 두 객체가 협력하게 한다.

**책임 할당시 고려사항 2가지**

1. 메시지가 객체를 결정한다.
    - 객체가 **최소한의 인터페이스(minimal interface)**를 가질 수 있게 된다.
    - 객체는 충분히 **추상적인 인터페이스(abstract interface)**를 가질 수 있게 된다.

2. 행동이 상태를 결정한다.
    - 객체가 존재하는 이유는 협력에 참여하기 위해서다. 따라서 객체를 객체답게 만드는 것은 **상태**가 아닌 **행동**이다.

캡슐화를 위반하지 않기 위해 구현을 뒤로 미루면서 객체의 행위를 고려하기 위해서는 항상 협력이라는 문맥 안에서 객체를 생각해야한다.

만약 객체의 행동이 아닌 상태에 초점을 맞춘다면 객체의 내부 구현이 객체의 퍼블릭 인터페이스에 노출되도록 만들어지기 때문에 **캡슐화를 저해**한다. 이런 설계 방법을 **데이터 주도 설계(Data-Driven Design)**라고 부른다.
이는 우리가 위에서 알아본 **책임 주도 설계(RDD)**와는 상반된다.

개별 객체의 상태와 행동이 아닌 시스템의 기능을 구현하기 위한 협력에 초점을 맞춰야만 응집도가 높고, 결합도가 낮은 객체를 만들 수 있다.
**상태는 단지 정상적인 행동을 수행하기 위한 재료일 뿐이다.**

# ⭐️ 역할
객체는 협력이라는 주어진 문맥 안에서 특정한 목적을 갖게 된다. 객체의 목적은 협력 안에서 객체가 맡게 되는 책임의 집합으로 표시된다. 이처럼 객체가 어떤 특정한 협력 안에서 수행하는 **책임의 집합**을 **역할**이라고 한다.

예를 들어 영화 예매 협력에서 _예매하라_라는 메시지를 처리하기에 적합한 개체로 Screening을 선택했다.
하나의 단계처럼 보이는 이 책임 할당 과정은 실제로는 두 개의 독립적인 단계가 합쳐진 것이다.

1. 영화를 예매할 수 있는 적절한 역할이 무엇인가를 찾는다.
2. 역할을 수행할 객체로 Screening 인스턴스를 선택한다.

![](https://velog.velcdn.com/images/pp8817/post/4ec1c72e-dc25-400e-b435-91f781620228/image.png)

그렇다면 어떤 이유로 역할이라는 개념을 이용해서 설계 과정을 더 번거롭게 만드는 것일까? 어차피 역할이 없어도 객체만으로 충분히 협력을 설계할 수 있는 거 아닌가?

## 📌 유연하고 재사용 가능한 협력
**역할이 중요한 이유**
- 역할을 통해 **유연하고 재사용 가능한 협력**을 얻을 수 있기 때문이다.
- - -
역할이라는 개념을 고려하지 않고 객체에게 책임을 할당한다고 가정해보자.
Movie가 가격을 계산하기 위해서는 할인 요금이 필요하다.

```
할인 요금을 계산하라
```
라는 메시지를 전송해서 외부의 객체엑 도움을 요청한다.

금액 할인 정책과 비율 할인 정책이라는 두 가지 종류의 가격 할인 정책이 존재하기 때문에 `AmountDiscountPolicy`, `PercentDiscountPolicy0` 인스턴스 두 가지 종류의 객체가 `할인 요금을 계산하라` 메시지에 응답할 수 있어야 한다.

그렇다면 두 종류의 객체가 참여하는 협력을 개별적으로 만들어야 할까?
![](https://velog.velcdn.com/images/pp8817/post/07c38d09-c40a-404a-9412-18481c65bbbd/image.png)
아니다!
문제를 해결하기 위해서는 객체가 아닌 책임에 초점을 맞춰야 한다. 순수하게 책임의 관점에서 두 협력을 바라보면 두 인스턴스 모두 할인 요금 계산이라는 **동일한 책임**을 수행한다는 것을 알 수 있다.

따라서 객체라는 존재를 지우고 `할인 요금을 계산하라`라는 메시지에 응답할 수 있는 대표자를 생각한다면 두 협력을 하나로 통합할 수 있을 것이다. 이 대표자를 협력 안에서 두 종류의 객체를 교대로 바꿔 끼울 수 있는 일종의 **슬롯**으로 생각할 수 있다. 이 슬록이 바로 **역할**이다.

![](https://velog.velcdn.com/images/pp8817/post/0b5d2946-17ef-4f79-a3d2-7c03c990a3ff/image.png)
여기서의 역할이 두 종류의 객체를 포괄하는 **추상화**이다.

> - 만약 협력에 적합한 책임을 수행할 대상이 한 종류라면 **객체**로 간주한다.
- 만약 여러 종류의 객체들이 참여할 수 있다면 **역할**로 간주한다.

- - -
**출처** <br>
[오브젝트 - 코드로 이해하는 객체지향 설계](https://smartstore.naver.com/aladinstores/products/7815204109?NaPm=ct%3Dlsvyemdc%7Cci%3Da772aefc1b71a76e7f3412247dc9108aec75e0f6%7Ctr%3Dboksl%7Csn%3D4399901%7Chk%3D0c624b3c7c58fc3c0cc29d777797044a631fb294)   <br>
https://github.com/eternity-oop/object
