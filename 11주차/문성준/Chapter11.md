# ch11 합성과 유연한 설계

---

### 서론

상속과 합성은 코드 재사용 기법이다.

상속이 부모 클래스와 자식 클래스를 연결해서 부모 클래스의 코드를 재사용 하는 데 비해
합성은 전체를 표현하는 객체가 부분을 표현하는 객체를 포함해서 부분 객체의 코드를 재사용한다.

상속에서 부모 클래스와 자식 클래스 사이의 의존서응ㄴ 컴파일 타임에 해결되지만,
합성에서 두 객체 사이의 의존성은 런타임에 해결된다.

상속 관계는 is-a관계, 합성은 has-a 관계다.

합성은 구현에 의존하지 않는다는 점에서 상속과 다르다.
합성은 내부에 포함되는 객체의 구현이 아닌 퍼블릭 인터페이스에 의존한다.

상속 관계는 클래스 사이의 정적인 관게인 데 비해 합성 관계는 객체 사이의 동적인 관계다.

코드 작성 시점에 결정한 상속 관계는 변경이 불가능하지만 합성 관게는 실행 시점에 동적으로 변경할 수 있기 때문이다.

> 객체 합성이 클래스 상속보다 더 좋은 방법이다.
> 

상속은 화이트박스 재사용 이라고도 불리며, 상속을 받으면 부모 클래스의 내부가 자식 클래스에 공개되기 때문에 화이트 박인 셈이다.

합성하려면 합성할 객체들의 인터페이스를 명확하게 정의해야한다. 이를 블랙박스 재사용 이라고도 부르며, 객체의 내부는 공개되지 않고 인터페이스를 통해서만 재사용되기 때문이다.

---

# 상속을 합성으로 변경하기

## 상속의 문제점

1. 불필요한 인터페이스 상속 문제
자식 클래스에게는 부적합한 부모 클래스의 오퍼레이션이 상속되기 때문에 자식 클래스 인스턴스의 상태가 불안정해지는 문제.
2. 메서드 오버라이딩의 오작용 문제
자식 클래스가 부모 클래스의 메서드를 오버라이딩할 때 자식 클래스가 부모 클래스의 메서드 호출 방법에 영향을 받는 문제.
3. 부모 클래스와 자식 클래스의 동시 수정 문제
부모 클래스와 자식 클래스 사이의 개념적인 결합으로 인해 부모 클래스를 변경할 때 자식 클래스도 함께 변경해야 하는 문제.

상속을 합성으로 바꾸는 방법은 자식 클래스에 선언된 상속 관계를 제거하고, 부모 클래스의 인스턴스를 자식클래스의 인스턴스 변수로 선언하면 된다.

---

## 메서드오버라이딩의 오작용 문제

HashSet에 대한 구현 결합도는 제거하면서도 퍼블릭 인터페이스는 그대로 상속받을 수 있는 방법 ?

→ 자바의 인터페이스를 사용하면 된다.

→ HashSet은 Set 인터페이스를 실체화하는 구현체 중 하나이기 때문이다.

→ Set 인터페이스를 실체화하면서 내부에 HashSet의 인스턴스를 합성하면 HashSet에 대한 구현 결합도는 제거하면서도 퍼블릭 인터페이스는 그대로 유지할 수 있다.

- 포워딩 : Set의 오퍼레이션을 오버라이딩한 인스턴스 메서드에서 내부의 HashSet 인스턴스에게 동일한 메서드 호출을 그대로 전달하는 것이다.
- 포워딩 메서드 : 동일한 메서드를 호출하기 위해 추가된 메서드

포워딩은 기존 클래스의 인터페이스를 그대로 외부에 제공하면서 구현에 대한 결합 없이 일부 작동 방식을 변경하고 싶은 경우에 사용할 수 있는 유용한 기법이다.

---

## 부모 클래스와 자식 클래스의 동시 수정 문제

구현에 대한 결합보다는 인터페이스에 대한 결합이 더 좋다.

합성으로 수정하더라도 부모 클래스와 자식 클래스의 동시 수정 문제가 해결되지 않을 수 있다.

- 몽키 패치 : 현재 실행 중인 환경에만 영향을 미치도록 지역적으로 코드를 수정하거나 확장하는 것

---

<aside>
🦖 여기서 궁금하셔야 할 것들이 있습니다.
1. 자바의 컬렉션이란 무엇이고, 무엇들이 있을까 ?
2. 자바에서 AOP란 무엇일까?
3. Spring에서 AOP란 ?
→ 이에 대해 답변을 하지 못한다면 다시 공부하시길 권장합니다.

</aside>

제가 생각한 답)

### **1. 자바의 컬렉션이란 무엇이고, 무엇들이 있을까?**

자바의 컬렉션 프레임워크(Collection Framework)는 데이터 그룹을 메모리에서 효율적으로 관리하고 처리하기 위한 클래스와 인터페이스의 집합입니다. 이 프레임워크를 사용하면 기본적인 데이터 구조(예: 배열, 리스트, 큐, 스택, 트리, 해시 테이블 등)와 알고리즘을 재사용할 수 있어, 데이터를 조작하는 데 필요한 시간과 노력을 크게 줄일 수 있습니다.

**주요 컬렉션 인터페이스**

- **List**: 순서가 있는 데이터의 집합으로, 중복을 허용합니다. 대표적으로 **`ArrayList`**, **`LinkedList`** 등이 있습니다.
- **Set**: 중복을 허용하지 않는 데이터의 집합입니다. 순서를 유지하지 않는 **`HashSet`**과 순서를 유지하는 **`LinkedHashSet`**, 정렬된 순서로 데이터를 관리하는 **`TreeSet`** 등이 있습니다.
- **Queue**: FIFO(First In First Out) 정책을 따르는 순서대로 데이터를 관리합니다. **`LinkedList`**가 **`Queue`** 인터페이스를 구현하며, **`PriorityQueue`**는 우선순위에 따라 요소를 관리합니다.
- **Map**: 키와 값의 쌍으로 데이터를 관리합니다. 키는 중복을 허용하지 않으며, **`HashMap`**, **`LinkedHashMap`**, **`TreeMap`** 등이 있습니다.
- Stack : LIFO.

### **2. 자바에서 AOP(Aspect-Oriented Programming)란 무엇일까?**

AOP는 관점 지향 프로그래밍으로, 애플리케이션의 핵심 관심 사항과 공통 관심 사항(크로스 커팅 관심 사항)을 분리하여 프로그램의 모듈성을 향상시키는 프로그래밍 패러다임입니다. 공통 관심 사항은 여러 모듈에서 공통적으로 사용하는 기능(예: 로깅, 보안, 트랜잭션 처리 등)을 말하며, AOP를 통해 이러한 기능을 별도의 모듈로 분리하고, 필요한 지점에서 동적으로 적용할 수 있습니다.

### **3. Spring에서 AOP란?**

스프링 프레임워크에서 AOP는 스프링의 핵심 개념 중 하나로 채택되어 있습니다. 스프링 AOP를 통해 개발자는 비즈니스 로직에서 공통적으로 사용하는 기능(트랜잭션 관리, 보안, 로깅 등)을 분리하여 관리할 수 있습니다. 이는 코드의 재사용성을 높이고, 유지보수를 용이하게 하며, 애플리케이션의 가독성을 향상시킵니다.

스프링 AOP는 주로 프록시 기반의 AOP 구현을 제공하며, AspectJ 어노테이션 스타일의 구성을 지원합니다. 스프링 AOP를 사용하여 개발자는 **`@Aspect`** 어노테이션을 사용해 애스펙트(@Aspect)를 정의하고, 어드바이스(Advice)를 통해 특정 조인 포인트(Join Point, 적용 지점)에 행동을 정의할 수 있습니다. 이를 통해 애플리케이션 전반에 걸쳐 일관된 방식으로 공통 기능을 적용할 수 있습니다.

---

# 상속으로 인한 조합의 폭발적인 증가

- 합성을 사용하라는 말은 구현이 아닌 인터페이스에 의존하라는 것이다.
- 설계는 다양한 조합을 수용할 수 있도록 유연해야 한다.

만약, 결합도를 낮추고 싶다면?

결합도를 낮추는 방법은 자식 클래스가 부모 클래스의 메서드를 호출하지 않도록 부모클래스에 추상메서드를 제공하는 것이다. 

**그렇다면, 부모 클래스에 추상메서드를 제공한다는게 무슨 말이지?**

→ 부모 클래스에 추상메서드를 제공한다는 것은, 부모 클래스에서 특정 메서드의 구현을 강제하지 않고, 그 메서드의 시그니처(즉, 메서드의 이름, 입력 매개변수, 반환 타입)만을 정의해 두는 것을 의미합니다.
이렇게 함으로써, 상속받는 자식 클래스에서 그 메서드를 자신의 상황에 맞게 구현하도록 합니다.
 이 방식은 객체 지향 프로그래밍에서 결합도를 낮추고, 확장성과 유연성을 높이는 데 도움을 줍니다.

### **결합도 낮추기의 중요성이란 ?**

결합도란 한 모듈(클래스, 컴포넌트 등)이 다른 모듈에 얼마나 의존하고 있는지를 나타내는 척도입니다. 
결합도가 높으면, 한 모듈을 변경할 때 다른 모듈에도 영향을 미치게 되어 시스템의 유지보수성이 떨어지고, 확장성이 제한됩니다. 반대로 결합도가 낮다면, 모듈 간의 의존성이 줄어들어 한 모듈의 변경이 다른 모듈에 미치는 영향이 적어지며, 유지보수와 확장이 용이해집니다.

### **추상 메서드와 추상 클래스**

- **추상 메서드**는 구현 부분 없이 메서드의 선언만 있는 메서드입니다. 
이 메서드는 상속받는 자식 클래스에서 반드시 구현해야 합니다.
- **추상 클래스**는 하나 이상의 추상 메서드를 포함하는 클래스로, 이 클래스 자체로는 인스턴스를 생성할 수 없습니다. 추상 클래스는 주로 상속의 목적으로 사용되며, 상속받는 자식 클래스에서 추상 메서드를 구현해야 합니다.

### **추상 메서드를 제공함으로써 결합도 낮추기**

부모 클래스에 추상 메서드를 제공함으로써, 자식 클래스는 부모 클래스의 구현 세부사항에 의존하지 않고, 
오직 정의된 인터페이스(추상 메서드)만을 따라 자신만의 구현을 제공할 수 있습니다. 
이러한 접근 방식은 다음과 같은 장점을 가집니다

1. **확장성**: 새로운 자식 클래스를 추가하기 쉬워지며, 각 자식 클래스는 같은 인터페이스를 구현하되 다른 방식으로 동작할 수 있습니다.
2. **유연성**: 시스템의 다른 부분들이 구체적인 구현보다는 인터페이스에 의존함으로써, 구현 방식의 변경이나 다른 구현의 사용이 용이해집니다.
3. **유지보수성**: 각 모듈(클래스)이 느슨하게 결합되어 있어, 하나의 모듈을 수정하거나 교체하는 것이 다른 모듈에 미치는 영향을 최소화합니다.

추상 클래스와 추상 메서드를 활용하는 것은 객체 지향 설계 원칙 중 하나인 "프로그램에서 구현이 아닌 인터페이스에 의존하라"의 구현 방법 중 하나입니다.

다시 말해, 부모클래스가 자신이 정의한 추상메서드를 호출하고, 자식 클래스가 이 메서드를 오버라이딩해서,
부모 클래스가 원하는 로젝을 제공하도록 수정하면, 부모 클래스와 자식 클래스 사이의 결합도를 느슨하게 만들 수 있다는 것을 의미합니다.

부모 클래스에 추상 메서드를 추가하면 모든 자식 클래스들이 추상 메서드를 오버라이딩해야 하는 문제가 발생한다.자식 클래스의 수가 많을 경우에는 꽤나 번거로운 일이 될 수 밖에 없다. 

모든 추상 메서드의 구현이 동일하다는 사실에도 주목하기 바란다.

이제 메서드를 오버라이딩할 필요가 없다. Phone(부모 클래스)에서 메서드에 대한 기본 구현을 했기 때문이다.

객체지향 언어는 단일 상속만 지원하기 때문에 상속으로 인해 발생하는 중복 코드 문제를 해결하기가 쉽지 않다.

---

중복 코드가 어떤 문제를 초래하는지 살펴보자.

## 중복 코드의 덫에 걸리다

상속을 이용한 해결 방법은 모든 가능한 조합별로 자식 클래스를 하나씩 추가하는 것이다.

상속 계층을 활용해 코드를 구성했다면, ERD 다이어그램을 그려보면 복잡성에 문제가 있다는 것을 깨우치게 될 것이고, 복잡성 보단 더 큰 문제가 있따.

새로운 정책을 추가하기가 어렵다는 것이다.

이는 매우 큰 설계의 문제점이다.

상속 계층에 새로운 기본 정책을 추가해야 한다고 가정한다면, 조합 가능한 부가 정책의 수만큼 새로운 클래스를 추가해야 한다.

이처럼 상속의 남용으로 하나의 기능을 추가하기 위해 필요 이상으로 많은 수의 클래스를 추가해야 하는 경우를 가리켜 **클래스 폭발** 또는 **조합의 폭발**이라고 한다.

자식 클래스와 부모 클래스의 다양한 조합이 필요한 상황에서 유일한 해결방법은 조합의 수만큼 새로운 클래스를 추가하는 것 뿐이다. 왜냐하면, 컴파일타임에 결정된 자식 클래스와 부모 클래스 사이의 관계는 변경될 수 없기 때문이다.

기능을 추가할 때뿐만 아니라 기능을 수정할 떄도 문제가 된다.

이 문제를 해결할 수 있는 최선의 방법은 상속을 포기하는 것이다.

---

# 합성 관계로 변경하기

상속 관계는 컴파일타임에 결정되고 고정되기 떄문에 코드를 실행하는 도중에는 변경할 수 없다.

합성은 컴파일타임 관계를 런타임 관계로 변경함으로써 이 문제를 해결한다.

합성을 사용하면 구현이 아닌 퍼블릭 인터페이스에 대해서만 의존할 수 있기 때문에 런타임에 객체의 관계를 변경할 수 있다.

클래스 폭발 문제를 해결하기 위해 합성을 사용하는 이유는 런타임에 객체 사이의 의존성을 자유롭게 변경할 수 있기 때문이다.

이것이 바로 합성의 본질이다.

합성을 사용하면, 구현 시점에 정책들의 관계를 고정시킬 필요가 없으며 실행 시점에 정책들의 관계를 유연하게 변경할 수 있게 된다.
상속이 조합의 결과를 개별 클래스 안으로 밀어 넣는 방법이라면 합성은 조합을 구성하는 요소들을 개별 클래스로 구현한 후  실행 시점에 인스턴스를 조립하는 방법을 사용하는 것이라고 할 수 있다.

컴파일 의존성에 속박되지 않고 다양한 방식의 런타임 의존성을 구성할 수 있다는 것이 합성이 제공하는 가장 커다란 장점인 것이다.

합성을 사용하면 연결되는 인터페이스의 구현 클래스가 어떤 타입인지에 따라 방식이 달라진다.

### 기본 정책과 부가 정책 합성하기

원하는 정책의 인스턴스를 생성한 후 의존성 주입을 통해 다른 정책의 인스턴스에 전달하는 것뿐이다.

여기서 DI가 무엇인지 모르겠다면, 찾아보는 것을 권장드립니다.

***객체를 조합하고 사용하는 방식이 상속을 사용한 방식보다 더 예측 가능하고 일관성이 있다.***

합성의 진가는 새로운 클래스를 추가하거나 수정하는 시점이 돼서야 비로소 알 수 있다.

### 새로운 정책 추가하기

더 중요한 것은 요구사항을 변경할 떄 오직 하나의 클래스만 수정해도 된다는 것.

## 객체 합성이 클래스 상속보다 더 좋은 방법이다

상속은 부모 클래스의 세부적인 구현에 자식 클래스를 강하게 결합시키기 떄문에 코드에 진화를 방해한다.

→ 코드의 재사용과 건전한 결합도를 유지할 수 있도록 합성을 이용하는 것이다.

### 그렇다면, 상속을 사용해야 하는 경우는 언제인가 ?

1. 먼저 상속을 구현 상속과 인터페이스 상속의 두 가지로 나눠야 한다는 사실을 이해해야 한다.
2. 이번 챕터에서 살표본 상속에 대한 모든 단점들은 구현 상속에 국한된다는 점 또한 이해해야 한다.
3. 챕터 13을 읽고 나면, 구현 상속을 피하고 인터페이스 상속을 사용해야 하는 이유를 이해해야 한다.

---

## 믹스인

상속과 합성의 특성을 모두 보유하고 있는 독특한 코드 재사용방법(기법)

상속과 합성의 장단점을 더 깊이 있게 이해시켜준다.

합성이 상속과 같은 문제점을 초래하지 않는 이유는 클래스의 구체적인 구현이 아니라 객체의 추상적인 인터페이스에 의존하기 때문입니다.

다시 말해, 상속은 코드 재사용을 위해 클래스 계층을 통해 기능을 확장하는 방식이며, 합성은 객체를 다른 객체의 일부로 만들어 코드를 재사용하는 방법입니다. 믹스인은 이 두 가지 접근 방식의 장점을 결합하여, 코드의 유연성과 재사용성을 높이는 방식입니다.

자바에서는 믹스인을 직접적으로 지원하지 않습니다. 
그러나 인터페이스와 합성을 사용하여 비슷한 결과를 달성할 수 있습니다. 
믹스인의 주요 개념은 여러 클래스에서 재사용할 수 있는 기능을 정의하는 것이며, 이는 인터페이스를 통해 달성할 수 있습니다. 다만, 인터페이스는 상태(필드)를 가질 수 없고 메소드 구현을 제공하지 않았었으나, Java 8 이후로는 default 메소드를 통해 메소드 구현을 제공할 수 있게 되었습니다.
이를 통해 믹스인과 유사한 기능을 구현할 수 있습니다.

다음은 Java에서 인터페이스와 합성을 사용하여 믹스인과 유사한 기능을 구현하는 예시입니다.

### **인터페이스를 사용한 믹스인 예시**

```java
// Flyable 인터페이스는 fly 메소드를 정의합니다.
interface Flyable {
    default void fly() {
        System.out.println("This object can fly.");
    }
}

// Drawable 인터페이스는 draw 메소드를 정의합니다.
interface Drawable {
    default void draw() {
        System.out.println("This object can be drawn.");
    }
}

// Bird 클래스는 Flyable과 Drawable 인터페이스를 구현합니다.
class Bird implements Flyable, Drawable {
    @Override
    public void fly() {
        Flyable.super.fly(); // Flyable의 기본 구현을 사용
    }

    @Override
    public void draw() {
        Drawable.super.draw(); // Drawable의 기본 구현을 사용
    }
}

public class MixinExample {
    public static void main(String[] args) {
        Bird bird = new Bird();
        bird.fly(); // "This object can fly." 출력
        bird.draw(); // "This object can be drawn." 출력
    }
}

```

이 예제에서 **`Bird`** 클래스는 **`Flyable`**과 **`Drawable`** 인터페이스를 통해 "날 수 있음"과 "그려질 수 있음"이라는 두 가지 기능을 믹스인합니다. **`Flyable`**과 **`Drawable`** 인터페이스는 각각 **`fly`**와 **`draw`** 메소드의 기본 구현을 제공합니다. 이렇게 함으로써, **`Bird`** 클래스는 이러한 메소드를 직접 구현하지 않고도 이 기능들을 사용할 수 있습니다.

그렇다면 결합도를 유지할 수 있는 유일한 방법인 재사용에 적합한 추상화를 도입하는 것은 ?

위 코드를 보면 아시다시피 추상화를 통해, 구체적인 구현 대신 인터페이스(또는 추상 클래스)에 의존하게 되며, 이는 더 유연하고 확장 가능한 코드 설계를 가능하게 합니다. 이러한 접근 방식은 소프트웨어 설계 원칙 중 하나인 "프로그램을 인터페이스에 대해 프로그래밍하라, 구현에 대해서가 아니라"는 원칙(Design by Contract)을 따르는 것과도 일치합니다.

이전 예제에서 **`Flyable`**과 **`Drawable`** 인터페이스는 특정 행동(날 수 있음, 그려질 수 있음)에 대한 추상화를 제공합니다. 이러한 인터페이스를 구현함으로써 **`Bird`** 클래스는 이 행동들을 재사용할 수 있게 되며, 이 과정에서 클래스 간의 강한 결합이 형성되지는 않습니다. 
대신, 각 클래스는 인터페이스를 통해 정의된 계약에만 의존하게 됩니다.

믹스인은 객체를 생성할 때 코드 일부를 클래스 안에 섞어 넣어 재사용하는 기법입니다.
합성이 실행 시점에 객체를 조합하는 재사용 방법이라면 믹스인은 컴파일 시점에 필요한 코드 조각을 조합하는 재사용 방법입니다.

다시 말하지만 믹스인은 상속과는 다릅니다.

상속의 진정한 목적은 자식 클래스를 부모 클래스와 동일한 개념적인 범주로 묶어 is-a 관계를 만들기 위한 것이며,
그에 비해 믹스인은 말 그대로 코드를 다른 코드 안에 섞어 넣기 위한 방법입니다.

하지만 상속이 클래스와 클래스 사이의 관계를 고정시키는 데 비해 믹스인은 유연하게 관계를 재구성할 수 있습니다. 믹스인은 코드 재사용에 특화된 방법이면서도 상속과 같은 결합도 문제를 초래하지 않습니다. 믹스인은 합성처럼 유연하면서도 상속처럼 쉽게 코드를 재사용할 수 있는 방법입니다.

쉽게 말해 코드를 다른 코드 안에  유연하게 섞어 넣을 수 있다면 믹스인이라고 부를 수 있습니다.

---

### 믹스인 정리

앞에서 super 호출을 사용하지 말라고 했지만, 사용한다면 결합도가 높아지는 것 아닐까 라는 생각을 하게 될 것이다. extends 문은 단지 사용될 수 있는 문맥을 제한할 뿐이다. 상속받은 경우에만 믹스인될 수 있따.

상속은 정적이지만 믹스인은 동적이다.

상속은 부모 클래스와 자식 클래스의 관계를 코드를 작성하는 시점에 고정시켜 버리지만 믹스인은 제약을 둘뿐 실제로 어떤 코드에 믹스인될 것인지를 결정하지 않습니다.

상속은 클래스 간의 계층적 관계를 형성하며, 이 관계는 컴파일 시간에 결정됩니다. 한 클래스가 다른 클래스를 확장(extends)할 때, 부모 클래스의 모든 속성과 메소드는 자식 클래스에게 상속되고, 이러한 관계는 변경할 수 없습니다. 이는 코드의 재사용성을 높이지만, 때로는 불필요한 결합도를 증가시키고 유연성을 저해할 수 있습니다.

반면에, 믹스인은 코드를 재사용하는 더 동적인 방법을 제공합니다. 믹스인은 특정 기능을 제공하는 클래스나 인터페이스를 다른 클래스에 "혼합"하여, 필요한 기능을 유연하게 추가할 수 있게 합니다.

자바에서는 인터페이스와 합성을 사용하여 믹스인과 유사한 효과를 달성할 수 있으나, 이는 상속보다는 인터페이스와 합성을 통해 동적으로 구현됩니다.

아래의 예시를 통해 상속과 믹스인이 자바 코드에서 어떻게 다르게 작동하는지 확인하면 보기 편하실 것입니다.

### **상속**

```java
class Animal {
    void eat() {
        System.out.println("This animal eats.");
    }
}

class Bird extends Animal {
    void fly() {
        System.out.println("This bird flies.");
    }
}

public class InheritanceExample {
    public static void main(String[] args) {
        Bird bird = new Bird();
        bird.eat(); // 상속받은 메소드
        bird.fly();
    }
}

```

이 예시에서 **`Bird`**는 **`Animal`**로부터 **`eat`** 메소드를 상속받습니다. **`Bird`**와 **`Animal`** 사이의 관계는 정적이며, 컴파일 시간에 결정됩니다.

### **믹스인 (Java에서 인터페이스를 활용한 유사 구현)**

```java
interface Flyable {
    default void fly() {
        System.out.println("This object can fly.");
    }
}

interface Eatable {
    default void eat() {
        System.out.println("This object can eat.");
    }
}

class Bird implements Flyable, Eatable {
    // Flyable과 Eatable 인터페이스를 통해 fly와 eat 메소드를 '믹스인'
}

public class MixinExample {
    public static void main(String[] args) {
        Bird bird = new Bird();
        bird.fly(); // 믹스인된 메소드
        bird.eat(); // 믹스인된 메소드
    }
}

```

이 예시에서 **`Bird`** 클래스는 **`Flyable`**과 **`Eatable`** 인터페이스를 구현함으로써, **`fly`**와 **`eat`** 메소드를 동적으로 '믹스인'합니다. 이 구현은 상속보다 더 유연하며, **`Bird`** 클래스는 필요한 인터페이스를 선택하여 필요한 기능을 혼합할 수 있습니다. 이 접근법은 결합도를 줄이고, 코드의 재사용성과 확장성을 높이는 장점이 있습니다.

상속이 클래스 간의 계층적이고 정적인 관계를 형성하는 반면, 믹스인은 더 동적이고 유연한 코드 재사용과 확장을 가능하게 합니다. 이 차이점은 자바와 같은 정적 타입 언어에서도 인터페이스와 합성을 통해 믹스인과 유사한 효과를 달성함으로써 더 잘 이해될 수 있습니다.

---

스칼라에서는 특정 클래스에 믹스인한 클래스와 트레이틀르 선형화해서 어떤 메서드를 호출할지 결정한다.

→ 이게 무슨말 ???

### **스칼라의 특성 선형화 예시**

스칼라에서는 다음과 같이 트레이트를 선언하고 클래스에 믹스인할 수 있습니다.

```scala

trait A {
  def doSomething() = println("A")
}

trait B extends A {
  override def doSomething() = { println("B"); super.doSomething() }
}

trait C extends A {
  override def doSomething() = { println("C"); super.doSomething() }
}

class D extends B with C {
  override def doSomething() = { println("D"); super.doSomething() }
}

val d = new D()
d.doSomething()

```

위 코드에서, **`D`** 클래스는 **`B`**와 **`C`** 트레이트를 믹스인하고 있습니다. **`D`**의 **`doSomething`** 메서드를 호출하면, 출력은 **`D C B A`**가 됩니다. 스칼라는 **`D`** 클래스의 트레이트를 선형화하여, 오른쪽에서 왼쪽으로 (**`C`**, **`B`**, **`A`**) 순서대로 메서드를 호출합니다.

### **자바에서의 상황**

자바에서는 스칼라의 트레이트와 같은 선형화 개념이 없습니다. 자바에서는 인터페이스를 사용하여 유사한 기능을 구현할 수 있지만, 인터페이스는 상태(필드)를 가질 수 없고, Java 8 이전에는 메서드 구현을 가질 수 없었습니다. Java 8 이후에는 인터페이스에 디폴트 메서드(default methods)를 사용하여 메서드 구현을 포함시킬 수 있게 되었습니다. 하지만, 자바의 인터페이스는 다중 상속의 문제(예: 같은 메서드 시그니처를 가진 여러 인터페이스의 구현을 한 클래스가 상속받는 경우)를 해결하기 위해, 명시적으로 어떤 인터페이스의 메서드를 사용할지 지정해야 합니다.

### **자바에서의 유사 구현 예시**

자바에서는 다음과 같이 인터페이스의 디폴트 메서드를 사용하여 유사한 효과를 내려고 시도할 수 있지만, 충돌하는 메서드가 있을 경우 명시적으로 해결해야 합니다.

```java
interface A {
    default void doSomething() {
        System.out.println("A");
    }
}

interface B extends A {
    default void doSomething() {
        System.out.println("B");
        A.super.doSomething();
    }
}

interface C extends A {
    default void doSomething() {
        System.out.println("C");
        A.super.doSomething();
    }
}

class D implements B, C {
    public void doSomething() {
        System.out.println("D");
        C.super.doSomething(); // 명시적으로 C의 doSomething을 호출
        // B.super.doSomething(); // 필요한 경우, B의 doSomething을 호출하려면 이 라인을 활성화
    }
}

public class Main {
    public static void main(String[] args) {
        D d = new D();
        d.doSomething(); // 출력: D C A
    }
}

```

이 예시에서 **`D`** 클래스는 **`B`**와 **`C`** 인터페이스를 구현합니다. **`doSomething`** 메서드에서는 명시적으로 **`C.super.doSomething()`**을 호출하여 **`C`**의 구현을 사용합니다. 자바에서는 이와 같이 명시적으로 충돌을 해결해야 하며, 스칼라의 선형화와 같은 자동 해결 메커니즘이 없습니다. 따라서, 자바에서는 개발자가 구현의 선택과 순서를 직접 관리해야 합니다.

여기서 중요한 것은 믹스인되기 전까지는 상속 계층 안에서 트레이트 위치가 결정되지 않는다는 것입니다.
어떤 클래스에 믹스인할지에 따라 트레이트의 위치는 동적으로 변경되는 것입니다.

---

# 최종 정리

10장과 더불어 상속이 과연 좋을까 ? 라는 의문점을 가릴때 다형성이라는 대안책. 더 나아가 합성이라는 해결책이 있음을 알려주었다. 이에 대한 자세한 근거를 들어주었으며, 이해시켜주기 위한 저자의 노력이 깃든 챕터였다.
