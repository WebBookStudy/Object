# ch06 메시지와 인터페이스

가장 흔한 오해는 애플리케이션이 클래스의 집합으로 구성된다는 것이다.

협력 안에서 객체가 수행하는 책임에 초점을 맞춰야 한다.

책임 : 객체가 수신할 수 있는 메시지의 기반.

중요한 재료는 객체들이 주고받는 메시지다.

→ 애플리케이션은 클래스로 구성되지만 메시지를 통해 정의된다는 사실을 기억하자.

# 협력과 메시지

## 클라이언트 - 서버 모델

협력의 관점에서 객체는 2가지 종류의 메시지 집합으로 구성

1. 객체가 수신하는 메시지의 집합
2. 외부의 객체에게 전송하는 메시지의 집합

객체가 독립적으로 수행할 수 있는 것보다 더 큰 책임을 수행하기 위해서는 다른 객체와 협력해야 한다는 것.
그리고 두 객체 사이의 협력을 가능하게 해주는 매개체가 바로 메시지라는 것이다.

## 메시지와 메시지 전송

- 메시지는 (오퍼레이션명, 인자)로 구성
- 메시지 전송은 ( 메시지 수신자, 오퍼레이션명, 인자)

오퍼레이션 명은 condition.isSatisfiedBy(sc);
→ 여기서 condition : 수신자, isSatisfiedBy : 오퍼레이션명, sc : 인자

## 메시지와 메서드

메시지 수신자의 실제 타입이 무엇인가에 달려있다.

메시지를 수신했을 떄 실제로 실행되는 함수 또는 프로시저를 메서드라고 한다.

전통적인 방식의 갭라자는 어떤 코드가 실행될지를 정확하게 알고 있는 상황에서 함수 호출이나 프로지섲 호출 구문을 작성한다. 다시말해 코드의 의미가 컴파일 시점과 실행 시점에 동리하다는 것이다.

반면, 객체는 메시지와 메서드라는 두 가지 서로 다른 개념을 실행 시점에 연결해야 하기 때문에 컴파일 시점과 실행 시점의 의미가 달라질 수 있다.

메시지 전송자는 자신이 어떤 메시지를 전송해야 하는지만 알면 된다.
메시지 수신자 역시 누가 메시지를 전송하는지 알 필요가 없다.
단지 메시지가 도착했다는 사실만 알면 된다.
단, 메시지 수신자는 메시지를 처리하기 위해 필요한 메서드를 스스로 결정할 수 있는 자율권을 누린다.

## 퍼블릭 인터페이스와 오퍼레이션

- 객체가 의사소통을 위해 외부에 공개하는 메시지 집합을 퍼블릭 인터페이스라고 한다.
- 퍼블릭 인터페이스에 포함된 메시지를 오퍼레이션.
- 오퍼레이션은 수행가능한 어떤 행동에 대한 추상화.

흔히 내부의 구현 코드는 제외하고 단순히 메시지와 관련된 시그니처를 가리키는 경우가 대부분이다.
그에 비해 메시지를 수신했을 떄 실제로 실행되는 코드는 메서드라고 부른다.

> 오퍼레이션이란 실행하기 위해 객체가 호출될 수 있는 변환이나 정의에 관한 명세다.
인터페이스의 각 요소는 오퍼레이션이다.
오퍼레이션은 구현이 아닌 추상화다.
반면, 메서드는 오퍼레이션을 구현한 것이다.
인용하면 
“***메서드는 오퍼레이션에 대한 구현이며, 메서드는 오퍼레이션과 연관된 알고리즘 또는 절차를 명시한다***”
> 

# 인터페이스와 설계 품질

좋은 인터페이스는 

1. 최소한의 인터페이스 : 꼭 필요한 오퍼레이션만을 인터페이스에 포함한다.
2. 추상적인 인터페이스 : 어떻게 수행하는지가 아니라 무엇을 하는지를 표현한다.

두 조건을 만족한다.

RDD- 책임 주도 설계는

메시지를 먼저 선택함으로써 협력과는 무관한 오퍼레이션이 인터페이스에 스며드는 것을 방지한다.
따라서 인터페이스는 최소의 오퍼레이션만 포함하게 된다.
또한, 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하게 함으로써 클라이언트의 의도를 메시지에 표현할 수 있게한다.

> 훌륭한 인터페이스가 가지는 공통적인 특징을 아는 것은 개발자의 안목을 넓히고 올바른 설계에 도달할 수 있는 지름길을 제공할 것이다.
> 

퍼블릭 인터페이스의 품질에 미치는 영향을 미치는 다음과 같은 원칙과 기법

1. 디미터 법칙
2. 묻지말고 시켜라
3. 의도를 드러내는 인터페이스
4. 명령-쿼리 분석

- **디미터 법칙 :** 객체의 내부 구조에 강하게 결합되지 않도록 협력 경로를 제한
클래스가 특정한 조건을 만족하는 대상에게만 메시지를 전송하도록 프로그래밍 해야 한다.
모든 객체는 다음에 서술된 클래스의 인스턴스여야 한다.
- M의 인자로 전달된 클래스
- C의 인스턴스 변수의 클래스

이게 어렵지 않은가? 

나는 도대체 무슨 말인지 이해를 못했었다.
클래스 내부의 메서드가 아래 조건을 만족하는 인스턴스에만 메시지를 전송하도록 프로그래밍 한다고 보면된다.

- this 객체
- 메서드의 매개변수
- this의 속성
- this의 속성인 컬렉션의 요소
- 메서드 내에서 생성된 지역 객체

근데 문득 드는 생가이 있다. 이렇게 함으로써 얻는 이득이 무엇일까 ???

디미터 법칙(Law of Demeter, LoD)은 객체 지향 프로그래밍에서 객체 간의 결합도를 낮추기 위한 지침 중 하나입니다. 이 법칙을 따르면, 객체는 제한된 범위의 다른 객체와만 직접적으로 소통해야 하며, '알지 못하는' 객체와의 직접적인 소통은 피해야 합니다. 

### 얻을 수 있는 주요 이득

**1. 낮은 결합도**

객체가 직접 소통해야 하는 대상을 제한함으로써, 객체 간의 결합도가 낮아집니다. 이는 한 부분의 변경이 시스템의 다른 부분에 미치는 영향을 최소화하며, 이로 인해 시스템 전체의 유지보수성이 향상됩니다.

**2. 높은 응집도**

디미터 법칙을 따르는 클래스는 각자의 책임에 더 집중하게 됩니다. 클래스가 제한된 범위의 객체와만 소통하도록 함으로써, 클래스의 메서드들이 해당 클래스의 상태와 기능에 더욱 응집되어 있게 됩니다.

**3. 더 나은 재사용성**

결합도가 낮은 코드는 재사용하기가 더 쉽습니다. 객체나 클래스가 서로 강하게 연결되어 있지 않기 때문에, 하나의 객체나 클래스를 다른 컨텍스트나 프로젝트에서 재사용할 때 필요한 변경 사항이 적습니다.

**4. 이해하기 쉬운 코드**

객체가 직접 소통하는 대상이 제한될수록, 코드를 이해하기가 더 쉬워집니다. 각 객체의 역할과 책임이 명확해지며, 시스템의 다양한 부분 사이의 상호작용을 추적하기가 더 간단해집니다.

**5. 유연성과 확장성 향상**

결합도가 낮으면 시스템의 특정 부분을 수정하거나 확장하는 것이 더 쉬워집니다. 객체나 클래스가 서로에 대해 덜 알고 있기 때문에, 한 부분을 변경하더라도 시스템의 다른 부분에 미치는 영향이 적습니다. 이는 새로운 기능을 추가하거나 기존 기능을 변경할 때 필요한 노력을 줄여줍니다.

총합적으로, 디미터 법칙을 따르는 설계는 소프트웨어의 품질을 높이고, 개발 및 유지보수 과정을 용이하게 하며, 장기적으로는 프로젝트의 성공 가능성을 높이는 데 기여합니다.

디미터 법칙을 따르면 ***부끄럼타는 코드***를 작성할 수 있다.
불필요한 어떤 것도 다른 객체에게 보여주지 않으며, 다른 객체의 구현에 의존하지 않는 코드를 말한다.
클라이언트와 서버 사이에 낮은 결합도를 유지할 수 있다.
디미터 법칙을 위반하는 코드

```java
sc.getMovie().getDIscount();
```

어??? 이것만 보고 “시큐리티의 http().csrf().cors()등등 이런 것들 다 위반하는거 아니야 ??”
라고 생각할 수도 있다. 이 얘기는 이후에 하겠습니다.

***기차충돌***은 클래스의 내부 구현이 외부로 노출됐을떄 나타나는 전형적인 형태로 메시지 전송자는 메시지 수신자의 내부 정보를 자세히 알게 된다. 
따라서, 캡슐화는 무너지고, 내부 구현에 강하게 결합된다.

디미터 법칙을 따르도록 코드를 개선하면 메시지 전송자는 더 이상 메시지 수신자의 내부 구조에 관해 묻지 않게 된다.
단지 자신이 원하는 것이 무엇인지를 명시하고 단순히 수행하도록 요청한다.

```java
sc.calculate(ac);
```

디미터 법칙은 객체의 내부 구조를 ㅁ두는 메시지가 아니라 수신자에게 무언가를 시키는 메시지가 더 좋은 메시지라고 속삭인다.

## 묻지 말고 시켜라

훌륭한 메시지는 객체의 상태에 관해 묻지 말고 원하는 것을 시켜야 한다는 사실을 강조한다.

“묻지 말고 시켜라”

> 객체지향 코드는 객체에게 그것을 하도록 시킨다.
> 

내부의 상태를 이용해 어떤 결정을 내리는 로직이 객체 외부에 존재한다면 그건 리팩토링 대상이다.

상태를 묻는 오퍼레이션을 해동을 요청하는 오퍼레이션으로 대체함으로써 인터페이스를 향상시켜라.

“기차충돌”로 알려진, 일련의 getter들이 기차의 객차처럼 상호 연결되어 보이는 코드가 만들어지고 만다.

- "기차 충돌"의 전형적인 예

```java
String street = user.getDepartment().getManager().getAddress().getStreet();
```

이 코드에서는 **`user`** 객체에서 시작하여, **`getDepartment()`**, **`getManager()`**, **`getAddress()`**, 그리고 마지막으로 **`getStreet()`**를 차례대로 호출합니다.

이런 방식은 여러 문제를 야기하게 됩니다.

1. **내부 구조의 과도한 노출**
각 객체의 내부 구조가 외부에 과도하게 노출되어, 객체 간의 결합도가 높아집니다. 이로 인해 하나의 객체를 변경할 때 연쇄적으로 다른 객체들도 변경해야 할 수 있습니다.
2. **유지보수의 어려움**
만약 **`Department`** 클래스에서 **`getManager()`** 메서드의 이름을 변경하거나 **`Manager`** 객체를 가져오는 방식을 변경한다면, **`Manager`** 객체를 사용하는 모든 곳에서 코드를 수정해야 합니다.
3. **높은 변경 비용**
이 코드는 **`User`**, **`Department`**, **`Manager`**, **`Address`** 클래스가 서로 긴밀하게 결합되어 있음을 의미합니다. 따라서 이 중 하나에 변화가 생기면, 연결된 모든 부분에 영향을 미칠 수 있으며, 이는 예상치 못한 버그를 초래할 수 있습니다.

그렇다면 이것의 해결책은 무엇이 있을까 ??

### **해결책**

디미터 법칙을 준수하고 "기차 충돌" 문제를 해결하기 위한 방법 중 하나는, 필요한 정보를 직접 반환하는 메서드를 제공하는 것입니다. 
예를 들어, **`User`** 클래스에 사용자가 속한 부서의 매니저의 주소 거리를 반환하는 메서드를 추가할 수 있습니다.

```java
public class User {
    // 기존 코드

    public String getManagerStreet() {
        return this.department.getManager().getAddress().getStreet();
    }
}
```

그리고 사용하는 쪽에서는 다음과 같이 호출할 수 있습니다.

```java
String street = user.getManagerStreet();
```

이러한 방식으로, 내부 구조의 복잡성을 감추고 객체 간의 결합도를 낮출 수 있으며, 코드의 유지보수성을 향상시킬 수 있습니다.

즉, 디미터 법칙을 위반하는 설계는 **인터페이스와 구현의 분리 원칙**을 위반한다.

객체의 내부 구조는 구현에 해당하는 것이다.

위반한다는 것은 클라이언트에게 구현을 노출한다는 것을 의미하며,  작은 요구사항 변경에도 쉽게 무너지는 불안정한 코드를 얻게 되는 것이다.

디미터 법칙을 위반한 코드를 수정하는 일반적인 방법은 “**직접 자신의 책임을 수행하도록 시키는 것**”

## 의도를 드러내는 인터페이스

1. 메서드가 작업을 어떻게 수행하는지를 나타내도록 이름 짓는 것. (좋지 않은 스타일)
2. “어떻게”가 아니라 “무엇”을 하는지 드러내는 것.

### 인터페이스에 의도를 드러내자

오퍼레이션의 이름은 협력이라는 문맥을 반영해야 한다.
클라이언트가 객체에게 무엇을 원하는지를 명확하게 표현한다.

# 원칙의 함정

***초보자는 원칙을 맹목적으로 추종한다.*** → 이게 상당히 위험한 것이다.

원칙이 현재 상황에 부적합하다고 판단된다면 과감하게 원칙을 무시해야한다.

원칙을 아는 것보다 더 중요한 것은 언제 원칙이 유용하고 언제 유용하지 않은지를 판단할 수 있는 능력을 기르는 것이다.

## 디미터 법칙은 하나의 도트(.)를 강제하는 규칙이 아니다

디미터 법칙은 결합도와 관련된 것이며, 이 결합도가 문제가 되는 것은 객체의 내부 구조가 외부로 노출되는 경우로 한정된다.

기차 충돌처럼 보이는 코드라도 객체의 내부 구현에 대한 어떤 정보도 외부로 노출하지 않는다면 그것은 디미터 법칙을 준수한 것이다.

메서드들이 객체의 내부에 대한 어떤 내용도 묻지 않는다. 그저 객체를 다른 객체로 변환하는 작업을 수행하라고 시킬 뿐이다. 즉, “묻지 말고 시켜라”원칙을 위반하지 않는다.

### 질문을 하자.

> 여러 개의 도트를 사용한 코드가 객체의 내부 구조를 노출하고 있는가?
> 

## 결합도와 응집도의 충돌

내부 구조에 강하게 결합된 문제를 해결할 수 있는 방법은 질문하고, 판단하고, 객체에게 위임 메서드를 추가하는 것이다.

그러나, 객체에게 시키는 것이 항상 가능한 것은 아니다.

### 가끔은 물어야 한다.

> 소프트웨어 설계에 법칙이란 존재하지 않는다는 것이다.
> 

원칙을 맹신하지 마라.

원칙이 적절한 상황과 부적절한 상황을 판단할 수 있는 안목을 기르자.
설계는 트레이드오프의 산물이며, 
sw 설계에 존재하는 몇 안되는 법칙 중 하나는 “경우에 따라 다르다”라는 사실을 명심하자.

<aside>
👉 함수형 프로그래밍은 부수효과가 존재하지 않는 수학적인 함수에 기반한다.
따라서 함수형 프로그래밍에서는 참조 투명성의 장점을 극대화할 수 있으며 명령형 프로그래밍에 비해 프로그램의 실행 결과를 이해하고 예측하기가 더 쉽다.
또한 하드웨어의 발달로 병렬 처리가 중요해진 최근에는 함수형 프로그래밍의 인기가 상승하고 있으며 다양한 객체지향 언어들이 함수형 프로그래밍 패러다임을 접목시키고 있는 추세다,

</aside>

## 책임에 초점을 맞추자.

메시지를 먼저 선택하고 그 후에 메시지를 처리할 객체를 선택하는 것이다.

객체의 구현 이전에 객체 사이의 협력에 초점을 맞추고 협력 방식을 단순하고 유연하게 만드는 것이다.

### **1. 디미터 법칙 (Law of Demeter, LoD)**

디미터 법칙은 "최소 지식 원칙"이라고도 하며, 객체의 상호작용을 그 객체가 직접적으로 알고 있는 친구 객체까지만 제한하는 원칙입니다. 이 법칙에 따르면, 객체는 다음과 같은 객체와만 메시지를 주고받아야 합니다,.

- 자기 자신(this)
- 메서드의 매개변수
- 자신이 생성한 객체
- 자신의 속성

이 원칙은 객체 간의 결합도를 줄이고, 유지보수성을 향상시키는 데 도움을 줍니다.

### **2. 묻지말고 시켜라 (Tell, Don't Ask)**

"묻지 말고 시켜라" 원칙은 객체의 상태를 직접 묻고 그 상태에 따라 행동하기보다는, 객체에게 원하는 행동을 수행하도록 요청해야 한다는 지침을 말합니다. 
이는 객체가 자신의 상태를 스스로 관리하게 하고, 외부의 개입을 최소화함으로써 캡슐화를 강화합니다.

### **3. 의도를 드러내는 인터페이스 (Intention-Revealing Interfaces)**

의도를 드러내는 인터페이스 원칙은 클래스나 메서드의 이름이 그 기능을 명확하게 반영해야 한다는 원칙입니다. 이를 통해 코드의 가독성과 유지보수성이 향상됩니다.
 메서드나 변수의 이름만 보고도 그 역할이나 반환값, 파라미터의 의미를 쉽게 이해할 수 있어야 합니다.

### **4. 명령-쿼리 분리 원칙 (Command-Query Separation, CQS)**

명령-쿼리 분리 원칙은 메서드를 크게 두 가지 유형으로 구분하는 원칙입니다: 명령과 쿼리.
명령은 객체의 상태를 변경하는 작업을 수행하지만, 값을 반환하지 않습니다. 
반면, 쿼리는 객체의 상태에 대한 정보를 반환하지만, 객체의 상태를 변경하지 않습니다. 
이 원칙을 따르면, 코드의 예측 가능성과 이해하기 쉬움이 향상됩니다.

훌륭한 메시지를 얻기 위한 출발점은 RDD을 따르는 것이다.
RDD에선 객체가 메시지를 선택하는 것이 아니라 메시지가 객체를 선택하기 때문에 협력에 적합한 메시지를 결정할 수 있는 확률이 높아지기 떄문이다.
