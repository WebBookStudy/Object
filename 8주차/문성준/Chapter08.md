# ch08 의존성 관리하기

### 서론

객체지향 설계의 핵심은 협력을 위해 필요한 의존성은 유지하면서도 변경을 방해하는 의존성은 제거하는데 있다.

이번 장에서는 충분히 협력적이면서도 유연한 객체를 만들기 위해 의존성을 관리하는 방법을 알아볼 것이다.

---

# 의존성 알아보기

## 변경과 의존성

의존성은 크게

1. **실행시점**
의존하는 객체가 정상적으로 동작하기 위해서는 실행 시에 의존 대상 객체가 반드시 존재해야 한다.
2. **구현 시점**
의존 대상 객체가 변경될 경우 의존하는 객체도 함께 변경된다.

이처럼 어떤 객체가 예정된 작업을 정상적으로 수행하기 위해 다른 객체를 필요로 하는 경우 두 객체 사이에 의존성이 존재한다고 말한다. 의존성은 방향성을 가지며 항상 단방향이다.
Screening이 변경될 때 PeriodCodition이 영향을 받게 되지만 그 역은 성립하지 않는다.
이 경우 PeriodCodition이은 Screening에 의존하며 그림 8.1에 표현한 것처럼 PeriodCodition은 Screening으로 향하는 점선 화살표로 표시한다.

두 요소 사이의 의존성은 의존되는 요소가 변경될 때 의존하는 요소도 함께 변경될 수 있다는 것을 의미한다.

따라서 PeriodCondition은 DayOfWeek(), LocalTime(), Screening()에 대해 의존성을 가진다.
(그림 8.2, 8.3 참고)

---

## 의존성 전이

의존성 전이가 의미하는 것은 PeriodCondition이 Screening에 의존할 경우 PeriodCondition은 Screening이 의존하는 대상에 대해서도 자동적으로 의존하게 된다는 것이다. 다시 말해서 Screening이 가지고 있는 의존성이 Screening에 의존하고 있는 periodCondition으로도 전파된다는 것이다.

의존성은 전이될 수 있기 떄문에 의존성의 종류를 직접 의존성과 간접 의존성으로 나누기도 한다.

## 런타임 의존성과 컴파일타임 의존성

런타임은 간단하다.

말 그대로 애플리케이션이 실행되는 시점이다.

컴파일 타임은 작성된 코드를 컴파일 하는 시점을 일반적으로 말하지만,
문맥에 따라서는 코드 그 자체를 가리키기도 한다.

객체지향 애플리케이션에서 런타임의 주인공은 객체다.

반면 코드 관점에서 주인공은 클래스다.

(그림 8-6참고)

Movie의 인스턴스가 이 두클래스의 인스턴스와 함께 협력할 수 있게 만드는 더 나은 방법은Movie가 두 클래스 중 어떤 것도 알지 못하게 만드는 것이다. 대신 두 클래스 모두를 포괄하는 DiscountPolicy라는 추상 클래스에 의존하돌고 만들고 이 컴파일타임 의존성을 실행 시에 PercentDiscountPolicy 인스턴스나 AmountDiscountPolicy 인스턴스에 대한 런타임 의존성으로 대체해야 한다.

실제로 협력할 객체가 어떤 것인지는 런타임에 해결해야 한다.

클래스가 협력할 객체의 클래스를 명시적으로 드러내고 있다면 다른 클래스의 인스턴스와 협력할 가능성 자체가 없어진다.

따라서 ***컴파일타임 구조와 런타임 구조 사이의 거리가 멀면 멀수록 설계가 유연해지고 재사용 가능해진다***.

## 컨텍스트 독립성

클래스는 자신과 협력할 객체의 구체적인 클래스에 대해 알아서는 안된다.

구체적인 클래스를 알면 알수록 그 클래스가 사용되는특정한 문맥에 강하게 결합되기 때문이다.

클래스가 특정한 문맥에 강하게 결합될수록 다른 문맥에서 사용하기는 더 어려워진다.

클래스가 사용될 특정한 문맥에 대해 최소한의 가정만으로 이뤄져 있다면 다른 문맥에서 재사용하기가 더 수월해진다. 이를 ***컨텍스트 독립성***이라고 부른다.

## 의존성 해결하기

컴파일타임 의존성을 실행 컨텍스트에 맞는 적절한 런타임 의존성으로 교체하는 것을 의존성 해결이라고 부른다.

***의존성을 해결***하기 위해서는 다음과 같은 세 가지 방법이 존재한다.

1. 객체를 생성하는 시점에 생성자를 통한 의존성 해결
2. 객체 생성 후 setter 메서드를 통해 의존성 해결
3. 메서드 실행 시 인자를 이용해 의존성 해결

### setter 메서드를 이용하는 방식

객체를 생성한 이후에도 의존하고 있는 대상을 변경할 수 있는 가능성을 열어 놓고 싶은 경우에 유용하다.

단점은 객체가 생성된 후에 협력에 필요한 의존 대상을 설정하기 떄문에 객체를 생성하고 의존 대상을 설정하기 전까지는 객체의 상태가 불완전할 수 있다는 점이다.

그렇다면 여기서 의문점을 가져야한다.

Setter 메서드를 이용하면 왜 좋다는 것일까 ?

1. **유연성 및 확장성**: Setter 메서드를 통해 객체가 생성된 후에도 의존 대상을 변경할 수 있습니다. 이는 프로그램이 실행되는 동안에 객체의 상태를 변경하고 유연하게 조정할 수 있도록 해줍니다. 즉, 객체를 다양한 상황에 맞게 동적으로 조작할 수 있습니다.
2. **테스트 용이성**: Setter 메서드를 이용하면 의존성을 주입하는 것이 용이해집니다. 이는 특히 유닛 테스트를 작성할 때 중요합니다. 객체가 외부 의존성에 의존하더라도, 테스트를 위해 가짜 객체(fake object)를 주입할 수 있습니다. 이는 테스트의 격리성을 유지하고, 테스트하기 쉬운 코드를 작성하는 데 도움이 됩니다.
3. **동적 변경**: Setter 메서드를 통해 의존 대상을 변경할 수 있으므로, 실행 중에 동적으로 의존성을 변경할 수 있습니다. 이는 어떤 시나리오에서는 필요한 기능입니다. 예를 들어, 런타임에 다른 데이터베이스 연결을 설정할 수 있습니다.
4. **의존성 해결의 외부화**: Setter 메서드를 통해 의존성을 주입하면 객체는 자체적으로 해당 의존성을 해결하지 않습니다. 대신 외부에서 주입되기 때문에 객체는 보다 단순해지고 의존성에 대한 컨트롤이 외부에 있게 됩니다.

그러나 Setter 메서드를 남용하면 코드의 복잡성이 증가할 수 있으며, 객체의 불변성(Immutability)을 해치거나 의존성을 명확하게 파악하기 어려운 코드를 작성할 수 있습니다. 적절한 상황에서 적절히 사용하는 것이 중요

## 코드로 알아보자.

### **Setter를 사용한 코드 예시**

```java

public class Car {
    private String brand;
    private String model;

    // Setter 메서드
    public void setBrand(String brand) {
        this.brand = brand;
    }

    public void setModel(String model) {
        this.model = model;
    }

    public String getBrand() {
        return brand;
    }

    public String getModel() {
        return model;
    }
}

public class Main {
    public static void main(String[] args) {
        Car car = new Car();

        // Setter를 통해 객체의 상태 설정
        car.setBrand("Toyota");
        car.setModel("Camry");

        System.out.println("Brand: " + car.getBrand());
        System.out.println("Model: " + car.getModel());
    }
}

```

### **Setter를 사용하지 않은 코드 예시**

```java

public class Car {
    private String brand;
    private String model;

    // 생성자를 통해 초기화
    public Car(String brand, String model) {
        this.brand = brand;
        this.model = model;
    }

    public String getBrand() {
        return brand;
    }

    public String getModel() {
        return model;
    }
}

public class Main {
    public static void main(String[] args) {
        // 생성자를 통해 객체의 상태 설정
        Car car = new Car("Toyota", "Camry");

        System.out.println("Brand: " + car.getBrand());
        System.out.println("Model: " + car.getModel());
    }
}

```

비교해 보면, Setter를 사용한 코드에서는 객체를 생성한 후에 **`setBrand()`**와 **`setModel()`** 메서드를 호출하여 객체의 상태를 설정합니다. 이를 통해 객체의 상태를 변경할 수 있습니다. 반면에 Setter를 사용하지 않은 코드에서는 객체를 생성할 때 생성자를 통해 초기화를 진행합니다. 이렇게 하면 생성된 객체의 상태는 변경할 수 없습니다.

Setter를 사용한 코드는 객체의 상태를 변경할 수 있는 유연성을 제공하지만, Setter 메서드를 사용하지 않는 코드는 객체의 불변성을 보장합니다. 선택은 프로그램의 요구사항과 설계 원칙에 따라 달라집니다.

### **더 좋은 방법은 생성자 방식과 setter 방식을 혼합하는 것이다.**

Setter 메서드를 사용하는 방식은 객체의 의존성 관리에 있어서 유연성을 제공합니다. 이는 특히 프로그램 실행 중에 객체의 상태나 의존하는 객체를 변경해야 할 때 유용합니다. 그러나 단점으로는 객체가 완전히 초기화되지 않은 상태로 남아있을 가능성이 있습니다. 즉, 객체가 생성된 후 적절한 setter 메서드를 호출하여 모든 의존성을 주입하지 않으면, 해당 객체는 완전한 상태가 아니므로 예상치 못한 오류가 발생할 수 있습니다.

생성자 방식과 setter 방식을 혼합하는 것은 이러한 문제를 해결하는 좋은 방법 중 하나입니다. 필수적인 의존성은 생성자를 통해 주입하여 객체가 항상 일관된 상태로 생성되도록 하고, 선택적인 의존성은 setter 메서드를 통해 주입할 수 있습니다. 이 방식을 사용하면 객체의 필수적인 부분은 누락 없이 안전하게 초기화되며, 동시에 유연성도 유지할 수 있습니다.

**자바 코드로 알아봅시다,**

```java
public class Product {
    private final String name; // 필수 의존성
    private int price; // 선택적 의존성

    // 생성자를 통해 필수 의존성을 주입
    public Product(String name) {
        this.name = name;
    }

    // Setter 메서드를 통해 선택적 의존성을 주입
    public void setPrice(int price) {
        this.price = price;
    }

    // Product 객체 사용을 위한 메서드 예시
    public void displayProductInfo() {
        System.out.println("Product Name: " + name + ", Price: " + price);
    }
}

public class Main {
    public static void main(String[] args) {
        // 생성자를 통해 필수 정보인 'name'을 주입하여 객체 생성
        Product product = new Product("Coffee");

        // setter를 사용하여 선택적 정보인 'price' 설정
        product.setPrice(100);

        // 객체 정보 출력
        product.displayProductInfo();
    }
}

```

이 예시에서 **`Product`** 클래스는 **`name`**이라는 필수 의존성을 가집니다. **`name`**은 객체 생성 시 생성자를 통해 반드시 주입되어야 하며, 이를 통해 **`Product`** 객체가 항상 유효한 상태로 시작할 수 있도록 합니다. **`price`**는 선택적 의존성으로, setter 메서드를 통해 나중에 설정할 수 있습니다. 이렇게 하면 필수적인 부분의 안전성은 보장하면서도, 필요에 따라 객체의 상태를 유연하게 변경할 수 있는 방법을 제공합니다.

다시 말해, 항상 객체를 생성할 떄 의존성을 해결해서 완전한 상태의 객체를 생성한 후, 필요에 따라 setter 메서드를 이용해 의존 대상을 변경할 수 있게 할 수 있다는 것이다. 이 방법은 시스템의 상태를 안정적으로 유지하면서도 유연성을 향상시킬 수 있기 때문에 의존성 해결을 위해 가정 선호되는 방법입니다.

여기서 더 나아가서 일시적으로 알아도 무방하다면 **메서드의 인자를 이용해 의존성을 해결하는 코드**

메서드의 인자를 사용하여 의존성을 해결하는 방법은 메서드 호출 시점에 필요한 의존성을 전달하는 방식입니다. 이 접근 방식은 특정 메서드가 실행될 때만 해당 의존성이 필요한 경우에 유용합니다. 이러한 방식을 "메서드 주입"이라고도 하며, 객체의 상태에 영향을 주지 않고 유연성을 유지하면서도 필요한 의존성을 제공할 수 있습니다.

**code**

```java
public class PaymentProcessor {
    // 이 클래스는 결제 처리 로직을 담당하지만, 로깅 기능은 메서드 인자를 통해 주입받습니다.

    public void processPayment(double amount, PaymentMethod paymentMethod, Logger logger) {
        // 결제 처리 로직
        paymentMethod.charge(amount);

        // 로깅 의존성을 메서드 인자를 통해 해결
        logger.log("Processed payment of " + amount + " using " + paymentMethod.getClass().getSimpleName());
    }
}

public interface PaymentMethod {
    void charge(double amount);
}

public class CreditCard implements PaymentMethod {
    @Override
    public void charge(double amount) {
        // 실제 결제 처리 로직 (여기서는 예시로만 표현)
        System.out.println("Charging " + amount + " to the credit card.");
    }
}

public class Logger {
    public void log(String message) {
        // 로깅 로직 (여기서는 콘솔 출력으로 간단히 대체)
        System.out.println("Log: " + message);
    }
}

public class Main {
    public static void main(String[] args) {
        PaymentProcessor processor = new PaymentProcessor();
        CreditCard creditCard = new CreditCard();
        Logger logger = new Logger();

        // 결제 처리를 위한 메서드 호출 시, 의존성인 'Logger' 인스턴스를 인자로 전달
        processor.processPayment(100.0, creditCard, logger);
    }
}
```

이 코드에서 **`PaymentProcessor`** 클래스는 결제를 처리하는 책임을 가지며, **`processPayment`** 메서드는 결제 수단(**`PaymentMethod`**)과 로깅을 위한 **`Logger`**를 인자로 받습니다. 이 방식을 통해 **`PaymentProcessor`** 클래스는 로깅 기능에 대한 직접적인 의존성 없이도 로깅 기능을 사용할 수 있게 됩니다. 로그를 기록하는 구체적인 방법은 **`Logger`** 클래스의 인스턴스에 위임되며, 이 인스턴스는 **`processPayment`** 메서드 호출 시에 제공됩니다. 이렇게 메서드의 인자를 통해 의존성을 주입함으로써, 클래스 간의 결합도를 낮추고 유연성을 높일 수 있습니다

# 유연한 설계

## 의존성과 결합도

객체지향의 패러다임의 근간은 ***협력***이다.

협력하기 위해서는 서로의 존재와 수행 가능한 책임을 알아야 한다.
이러한 지식들이 객체들의 의존성을 낳는다.
의존성은 객체드르이 협력을 가능하게 만드는 매개체다.

***문제는 의존성의 존재가 아니라 의존성의 정도다.***

만약, 두 추상 클래스가 협력해야 한다면 어떻게 해야하는 것일까 ?

→ 메시지를 이해할 수 있는 타입을 정의함으로써 이 문제를 해결한다.

바람직한 의존성은 재사용성과 관련이 있다.

어떤 의존성이 다양한 환경에서 재사용할 수 있다면 그 의존성은 바람직한 것이다.
다시 말해 컨텍스트에 독립적인 의존성은 바람직한 의존성이다.

## 지식이 결합을 낳는다

결합도의 정도는 한 요소가 자신이 의존하고 있는 다른 요소에 대해 알고 있는 정보의 양으로 결정된다.

서로에 대해 알고 있는 지식의 양이 결합도를 결정한다.

결합도를 느슨하게 만들고 협력하는 대상에 대해 필요한 정보 외에는 최대한 감추는 것은 추상화다.

## 추상화에 의존하라

**이는 곧 결합도를 낮추는 방법이다.**

복잡도를 극복하는 방법이다.

불필요한 정보를 감출 수 있다. 이로 인해 대상에 대해 알아야 하는 지식의 양을 줄일 수 있기 때문에 결합도를 느슨하게 유지할 수 있는 것이다.

아래쪽으로 갈수록 클라이언트가 알아야 하는 지식의 양이 적어지기 떄문에 결합도가 느슨해진다.

- 구체 클래스 의존성
- 추상 클래스 의존성
- 인터페이스 의존성

인터페이스 의존성은 협력하는 객체가 어떤 메시지를 수신할 수 있는지에 대한 지식만을 남기기 때문에 추상 클래스 의존성보다 결합도가 낮다. 이것은 다양한 클래스 상속 계층에 속한 객체들이 동일한 메시지를 수신할 수 있도록 컨텍스트를 확자앟는 것을 가능하게 한다.

여기서 중요한 것은, 결합도를 느슨하게 만들기 위해서는 구체적인 클래스보다 추상 클래스에,
추상 클래스보다 인터페이스에 의존하도록 만드는 것이 더 효과적이라는 것이다.

## 명시적인 의존성

구체 클래스의 인스턴스를 직접 생성해서 대입하고있다고 가정하면, 조상 클래스는 추상 클래스와 구체클래스에도 의존하게 된다.

그렇다면 의존성을 해결하는 방법은 ?

1. 생성자
2. setter 메서드
3. 메서드 인자 사용

생성자의 인자가 추상 클래스 타입으로 선언됐기 때문에 이제 객체를 생성할 때 생성자의 인자로 자식클래스 중 어떤 것이라도 전달할 수 있다. 따라서 런타임의 인스턴스나 다른 인스턴스를 선택적으로 전달할 수 있다.

따라서, Movie 인스턴스는 생성자의 인자로 전달된 인스턴스에 의존하게된다.

의존성의 대상을 생성자의 인자로 전달받는 방법과 생성자 안에서 직접 생성하는 방법 사이의 가장 큰 차이점은 퍼블릭 인터페이스를 통해 할인 정책을 설정할 수 있는 방법을 제공하는지 여부다.

생성자의 인자로 선언하는 방법은 Movie가 DiscountPolicy에 의존한다는 사실을 Movie의 퍼블릭 인터페이스에 드러내는 것이다. 이것은 setter 메서드를 사용하는 방식과 메서드 인자를 사용하는 방식의 경우에도 동일하다.

모든 경우에 의존성은 명시적으로 퍼블릭 인터페이스에 노출된다.

이를 **명시적인 의존성**이라 한다.  (표현되지 않은 것은 숨겨진 의존성이라 한다)

의존성이 명시적이지 않는다면 ?

1. 내부 구현을 직접 살펴볼 수밖에 없다.
2. 다른 컨텍스트에서 재사용하기 위해 내부 구현을 직접 변경해야 한다.

즉, 의존성은 명시적으로 표현돼야 한다.

의존성을 구현 내부에 숨겨두지 마라.

유연하고 재사용 가능한 설계란 퍼블릭 인터페이스를 통해 의존성이 명시적으로 드러나는 설계다.

명시적인 의존성을 사용해야만 퍼블릭 인터페이스를 통해 컴파일타임 의존성을 적절한 런타임 의존성으로 교체할 수 있다.

경계해야 할 것은 의존성 자체가 아니라 의존성을 감추는 것이다.

## new는 해롭다

클래스의 인스턴스를 생성할 수 있는 new 연산자를 제공한다.

결합도 측면에서 해로운 이유는 ?

1. new 연산자를 사용하기 위해서는 구체적인 클래스의 이름을 직접 기술해야한다.
따라서 new를 사용하는 클라이언트는 추상화가 아닌 구체 클래스에 의존할 수밖에 없기 때문에 결합도가 높아진다.
2. new 연산자는 생성하련느 구체 클래스뿐만 아니라 어떤 인자를 이용해 클래스의 생성자를 호출해야 하는지도 알아야 한다.
따라서 new를 사용하면 클라이언트가 알아야 하는 지식의 양이 늘어나기 떄문에 결합도가 높아진다.

new는 결합도를 높이기 때문에 해롭다.

해결 방법은 인스턴스를 생성하는 로직과 생성된 인스턴스를 사용하는 로직을 분리하는 것이다.

생성자를 통해 외부의 인스턴스를 전달받아 의존성을 해결한다면 ?

***무엇을? 어떻게 ? 왜 ? 가능하다는 거지 ?***

중요하니 다시 설명하겠습니다.

### **어떻게 해결하는가?**

- **의존성 주입**
인스턴스 생성 로직과 생성된 인스턴스를 사용하는 로직을 분리하는 것입니다. 이는 의존성 주입의 기본 원칙 중 하나로, 클래스가 자신이 필요로 하는 의존성(다른 클래스의 인스턴스)을 외부(예: 프레임워크, 컨테이너, 또는 클라이언트 코드)로부터 받게 됩니다.
- **생성자 주입**: 생성자를 통해 의존성을 주입받는 방식입니다. 이 방법은 객체가 생성될 때 필요한 모든 의존성이 준비되어 있어야 하며, 객체의 상태가 불완전한 경우를 방지할 수 있습니다.
- **세터 주입**: 세터 메서드(set 메서드)를 통해 의존성을 주입받는 방식입니다. 이 방법은 객체 생성 후에 의존성을 주입할 수 있으며, 선택적 의존성이 있는 경우 유용합니다
- **인터페이스 기반 주입**: 객체가 특정 인터페이스를 구현하고, 이를 통해 의존성을 주입받을 수 있도록 하는 방식입니다.

### **왜 가능한가?**

- **추상화를 통한 결합도 낮춤**: 의존성 주입을 통해, 구체 클래스가 아닌 인터페이스나 추상 클래스에 의존하게 만듦으로써 결합도를 낮출 수 있습니다. 이는 구체 클래스의 변경이 클라이언트 코드에 미치는 영향을 최소화하며, 코드의 유연성과 확장성을 증가시킵니다.
- **단일 책임 원칙(SRP)**: 객체 생성과 사용을 분리함으로써, 각 클래스는 자신의 책임에만 집중할 수 있습니다. 이는 코드의 가독성과 유지보수성을 향상시키며, 시스템의 다른 부분과의 의존성을 줄입니다.

### **결론**

**`new`** 연산자의 직접적인 사용은 결합도를 높이고 코드의 유연성을 저하시키는 문제를 야기할 수 있습니다. 의존성 주입을 통해 이러한 문제를 해결하고, 코드의 유연성과 확장성을 높일 수 있습니다. 이는 설계 원칙과 패턴을 적용하여 보다 유지보수가 용이하고 확장 가능한 소프트웨어를 개발하는 데 도움이 됩니다.

## 가끔은

클래스 안에서 객체의 인스턴스를 직접 생성하는 방식이 유용한 경우도 있다.

주로 협력하는 기본 객체를 설정하고 싶은 경우에 여기에 속한다.

## 표준 클래스에 대한 의존은 해롭지 않다.

변경될 확률이 거의 없는 클래스라면 의존성이 문제가 되지 않는다.

***JDK의 표준 컬렉션 라이브러리에 속하는 ArrayList의 경우에는 다음과 같이 직접 생성해서 대입하는 것이 일반적이다. ArrayList의 코드가 수정도리 확률은 0에 가깝기 떄문에 인스턴스를 직접 생성하더라도 문제가 되지 않기 떄문이다.***

## 컨텍스트 확장하기

생성자 체이닝 기법을 이용해 기본값으로 null을 할당하고 있다는 점을 눈여겨봐야한다.

### 만약, 협력하는 방식에 어긋나는 에외 케이스가 추가된다면 ?

해결책은, 존재하지 않는다는 사실을 예외 케이스로 처리하지 말고 기존에 협력하던 방식을 따르도록 만드는 것이다.

설계를 유연하게 만들 수 있었던 이유는 추상화에 의존하고, 생성자를 통해 의존성을 명시적으로 드러냈으며, new와 같이 구체 클래스를 직접적으로 다뤄야하는 책임을 외부로 옮겼기 떄문이다.

## 조합 가능한 행동

유연하고 재사용 가능한 설계는

객체가 HOW 하는지를 장황하게 나열하지 않고도 객체들의 조합을 통해 WHAT 하는지를 표현하는 클래스들로 구성하자.

### 핵심은 의존성을 관리하는 것이다.
